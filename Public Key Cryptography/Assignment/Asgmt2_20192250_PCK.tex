\documentclass{article}

% Packages for formatting
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{kotex}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{algorithm2e,setspace}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage{amssymb}

% Fonts
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{newpxtext,newpxmath}
\usepackage{sectsty}

% Define colors
\definecolor{blue1}{HTML}{0077c2}
\definecolor{blue2}{HTML}{00a5e6}
\definecolor{blue3}{HTML}{b3e0ff}
\definecolor{blue4}{HTML}{00293c}
\definecolor{blue5}{HTML}{e6f7ff}

\definecolor{thmcolor}{RGB}{231, 76, 60}
\definecolor{defcolor}{RGB}{52, 152, 219}
\definecolor{lemcolor}{RGB}{155, 89, 182}
\definecolor{corcolor}{RGB}{46, 204, 113}
\definecolor{procolor}{RGB}{241, 196, 15}

\usepackage{color,soul}
\usepackage{soul}
\newcommand{\mathcolorbox}[2]{\colorbox{#1}{$\displaystyle #2$}}


% Chapter formatting
\definecolor{titleblue}{RGB}{0,53,128}
\usepackage{titlesec}
\titleformat{\section}
{\normalfont\sffamily\Large\bfseries\color{titleblue!100!gray}}{\thesection}{1em}{}
\titleformat{\subsection}
{\normalfont\sffamily\large\bfseries\color{titleblue!50!gray}}{\thesubsection}{1em}{}

%Tcolorbox
\usepackage[most]{tcolorbox}

%Tikzpicture
\usepackage{tikz-cd}
\usetikzlibrary{positioning}

% Header and footer formatting
\pagestyle{fancy}
\fancyhf{}
\rhead{Student ID: 20192250\quad Name: 지용현}%\rule{3cm}{0.4pt}}
\lhead{\textcolor{blue2}{\textbf{PKC Assignment \#2}}}
% Define footer
\newcommand{\footer}[1]{
\begin{flushright}
	\vspace{2em}
	\includegraphics[width=2cm]{school_logo.jpg} \\
	\vspace{1em}
	\textcolor{blue2}{\small\textbf{#1}}
\end{flushright}
}
%\rfoot{\large Department of Information Security, Cryptogrphy and Mathematics, Kookmin Uni.\includegraphics[height=1.5cm]{school_logo.jpg}}

\newcommand{\ie}{\textnormal{i.e.}}
\newcommand{\rsa}{\mathsf{RSA}}
\newcommand{\rsacrt}{\mathsf{RSA}\textendash\mathsf{CRT}}
\newcommand{\inv}[1]{#1^{-1}}

\usepackage{amsthm}
\newtheorem{axiom}{Axiom}[section]
\newtheorem{theorem}{Theorem}
\newtheorem*{theorem*}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem*{lemma*}{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem*{remark}{Remark}
\newtheorem{exercise}{Exercise}[section]

%New Command
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\nbhd}{\mathcal{N}}

\newcommand{\of}[1]{\left( #1 \right)} 

\begin{document}

\begin{center}
	\huge\textbf{Public Key Cryptography}\\
	\vspace{0.5em}
\end{center}

%\tableofcontents

\section{Review of Chinese Remainder Theorem and Fermat's Little Theorem}
\subsection{Chinese Remainder Theorem ($\mathsf{CRT}$)}

\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf Bézout's Identity}]
	\begin{lemma*}
		$a,b\in\Z\implies\exists x,y\in\Z:\gcd\of{a,b}=ax+by$.
	\end{lemma*}
\end{tcolorbox}
\begin{remark}
	Let $a,b\in\Z$ and $\gcd\of{a,b}=1$. Bézout's identity guarantees $\exists x,y\in\Z:ax+by=1$ and so \[
	ax+by=1\implies ax=(-y)b+1\implies ax\equiv1\pmod{b}.
	\] That is, \[
	\mathcolorbox{-blue}{\gcd\of{a,b}=1\implies\exists x\in\Z:ax\equiv1\pmod{b}}.
	\] Similarly, if $a$ and $b$ are coprime, $b$ has a mutiplicative inverse modulo $a$.
\end{remark}

\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf Chinese Remainder Theorem ($\mathsf{CRT}$)}]
	\begin{theorem*}
		Given a system of $k$ linear congruences:
		\begin{align*}
			x&\equiv a_1 \pmod{m_1}\\
			x&\equiv a_2 \pmod{m_2}\\
			&\vdots \\
			x&\equiv a_k \pmod{m_k}
		\end{align*} where \textcolor{magenta}{$m_1,m_2,\dots, m_k$ are pairwise coprime}. Let $M=\prod_{i=1}^km_i$. Then, the \textcolor{red}{unique} \textcolor{blue}{solution} of the system of congruences is give by \begin{align*}
			X&=\sum_{i=1}^ka_iM_ib_i\pmod{M}\\
			&=a_1M_1b_1+a_2M_2b_2+\cdots+a_kM_kb_k\pmod{M}.
		\end{align*} where $M_i=M/m_i$ and $ b_i\equiv\inv{M_i}\pmod{m_i}$.
	\end{theorem*}
\end{tcolorbox}
\begin{proof}
	(\textcolor{blue}{Existence}) Let $M=m_1m_2\cdots m_k$ and $M_i=M/m_i$. Then, for all $i,j\in[1,k]$ with $i\neq j$, \[
	\textcolor{magenta}{\gcd\of{m_i,m_j}=1}\implies\gcd\of{m_i, M_i}=1\implies \exists b_i: b_iM_i\equiv1\pmod{m_i}. 
	\] Then we claim that $X=\sum_{i=1}^k a_i b_i M_i$ is a solution to the system of linear congruences: \begin{align*}
		X-a_i=\of{\sum_{j=1}^k a_j b_j M_j} - a_i&=\sum_{\substack{j=1\\ j\neq i}}^k a_j b_j M_j + a_ib_iM_i-a_i
		=\sum_{j=1,j\neq i}^k a_j b_j M_j + a_i(b_iM_i - 1)
	\end{align*}
	Now, we know that $
	b_iM_i-1\equiv 0\pmod{m_i}$ since $b_iM_i\equiv 1\pmod{m_i}$. Then we get \[
	X-a_i\equiv \sum_{\substack{j=1\\ j\neq i}}^k a_j b_j M_j \pmod{m_i}.
	\]
	Now, since $\gcd\of{m_i, M_j}=1$ and $M_j$ are coprime for all $j \neq i$, we know that $a_j b_j M_j \equiv 0 \pmod{m_i}$ for all $j \neq i$. Therefore, we have:
	
	$$X-a_i \equiv 0 \pmod{m_i}$$
	
	Therefore, $X$ satisfies all of the linear congruences.
	
	Next, we will show that $X$ is unique modulo $M$. Suppose that $X'$ is another solution to the system of linear congruences. Then for any $i=1,2,\cdots, k$, we have:
	
	$$X \equiv X' \pmod{m_i} \implies m_i | (X-X')$$
	
	Since $m_i$ are pairwise coprime, we have $M=\operatorname{lcm}(m_1, m_2, \ldots, m_k)$, which implies that $M$ divides $X-X'$. Therefore, $X$ and $X'$ are congruent modulo $M$, and so $X$ is unique modulo $M$.\\
	\\
	(\textcolor{red}{Uniqueness})
\end{proof}


\subsection{Fermat's Little Theorem ($\mathsf{FLT}$)}

\newpage

\section{Special Case of $\mathsf{CRT}$ and $\rsa$-$\mathsf{CRT}$ Algorithm}

\subsection{Two Linear Congruences for $\mathsf{CRT}$}

\iffalse
\begin{tcolorbox}[title=Chinese Remainder Theorem (CRT) - Special Case]
	\begin{theorem*}
		Given a system of $k$ linear congruences:
		\begin{align*}
			x&\equiv a_1 \pmod{m_1}\\
			x&\equiv a_2 \pmod{m_2}\\
			&\vdots \\
			x&\equiv a_k \pmod{m_k}
		\end{align*} where $m_1,m_2,\dots, m_k$ are pairwise coprime. Let $M=\prod_{i=1}^km_i$. Then, the unique solution of the system of congruences is give by \begin{align*}
			x&=\sum_{i=1}^ka_iM_ib_i\pmod{M}\\
			&=a_1M_1b_1+a_2M_2b_2+\cdots+a_kM_kb_k\pmod{M}.
		\end{align*} where $M_i=M/m_i$ and $ b_i\equiv\inv{M_i}\pmod{m_i}$.
	\end{theorem*}
\end{tcolorbox}\fi
\begin{tcolorbox}[title=Chinese Remainder Theorem (CRT) - Special Case]
	\begin{theorem*}
		Consider a system of two linear congruences:
		\begin{align*}
			x&\equiv a_1 \pmod{p}\\
			x&\equiv a_2 \pmod{q}
		\end{align*} where $p,q$ are coprime. Let $N=pq$. Then, the unique solution of the system of congruences is give by \begin{align*}
			\mathcolorbox{-blue}{x=a_1qq_p^{-1}+a_2pp_q^{-1}\mod{N}}
		\end{align*} where $q_p^{-1}=\inv{q}\mod{p}$ and $p_{q}^{-1}=\inv{p}\mod{q}$.
	\end{theorem*}
	\tcblower
	Recall that Bézout's identity : $
	a,b\in\mathbb{Z}\implies\exists x,y\in\mathbb{Z}:\gcd(a,b)=ax+by.
	$ Especially, \[
	\text{$p,q$ are coprime}\implies\exists x,y\in\mathbb{Z}: px+qy=1.
	\] Let $p,q$ are coprime. Then $\exists x,y\in\mathbb{Z}:px+qy=1$ and so \[
	px=(-y)q+1\quad\leadsto\quad px\equiv1\pmod{q}\quad\leadsto\quad x=p^{-1}\mod{q}.
	\] Similarly, $y=q^{-1}\mod{p}$. Thus we have $px+qy=1\leadsto pp_{q}^{-1}+qq_{p}^{-1}=1$. Consequently, \begin{align*}
		\mathcolorbox{-blue}{x=a_1qq_p^{-1}+a_2pp_q^{-1}\mod{N}} &\leftrightsquigarrow x=a_1qq_p^{-1}+a_2(1-qq_{p}^{-1})\mod{N}\\
		&\leftrightsquigarrow \mathcolorbox{-red}{x=(a_1-a_2)qq_p^{-1}+a_2\mod{N}}\\
	\end{align*}
\end{tcolorbox}

\subsection{Proof of Decryption of RSA}

\subsection*{Key Generation}
First, let's briefly review the key generation process in RSA:

\begin{enumerate}
	\item Choose two distinct prime numbers, $p$ and $q$.
	\item Compute $N = pq$.
	\item Calculate the Euler's totient function, $\phi(N) = (p - 1)(q - 1)$.
	\item Choose an integer $e$ such that $1 < e < \phi(N)$ and $\gcd(e, \phi(N)) = 1$.
	\item Compute $d \equiv e^{-1} \pmod{\phi(N)}$, the modular multiplicative inverse of $e$ modulo $\phi(N)$.
\end{enumerate}

The public key is $(N, e)$, and the private key is $(N, d)$.

\subsection*{Encryption}
Given a plaintext message $m$, the ciphertext $c$ is computed as follows:

\[
c \equiv m^e \pmod{N}
\]

\subsection*{Decryption}
Given a ciphertext $c$, the decrypted message $m$ is computed as follows:

\[
m \equiv c^d \pmod{N}
\]

\subsection*{Proof of Correctness}
To prove that decryption is correct, we need to show that the decrypted message $m$ is equal to the original plaintext message:

\[
(m^e)^d \equiv m \pmod{N}
\]

Using the property $ed \equiv 1 \pmod{\phi(N)}$, we can rewrite the equation as follows:

\[
m^{ed} \equiv m \pmod{N}
\]

Now, let's consider two cases:

\textbf{Case 1:} $\gcd(m, N) = 1$

In this case, we can apply Euler's theorem, which states that for any integer $a$ and positive integer $n$ such that $\gcd(a, n) = 1$:

\[
a^{\phi(n)} \equiv 1 \pmod{n}
\]

Using Euler's theorem, we can rewrite the equation as:

\[
m^{ed} \equiv m^{1 + k\phi(N)} \equiv m \cdot (m^{\phi(N)})^k \equiv m \pmod{N}
\]

\textbf{Case 2:} $\gcd(m, N) \neq 1$

In this case, $m$ must be divisible by one of the prime factors of $N$, either $p$ or $q$. Without loss of generality, let's assume that $m$ is divisible by $p$:

\[
m = p \cdot x
\]

for some integer $x$. Now, we can rewrite the equation as:

\[
m^{ed} \equiv (p \cdot x)^{ed} \equiv (p \cdot x) \pmod{N}
\]

In this case, both sides of the equation are divisible by $p$, so the congruence holds.

Therefore, in both cases, we have:

\[
m^{ed} \equiv m \pmod{N}
\]

This concludes the proof of RSA decryption correctness.

\newpage
\subsection{$\rsa$-$\mathsf{CRT}$ Algorithm}

\RestyleAlgo{ruled}
\SetKwComment{Comment}{/* }{ */}
\begin{algorithm}[H]
	\caption{$\mathsf{RSA}$-$\mathsf{CRT}$ Algorithm}
	\KwData{The security parameter $k$, a public key $(N,e)$, a ciphertext $\mathcal{C}$.}
	\KwResult{The plaintext message $\mathcal{M}$ corresponding to the ciphertext $\mathcal{C}$.}
	\vspace{4pt}
	\vspace{4pt}
	\SetKwFunction{KeyGen}{KeyGen}
	\SetKwProg{Fn}{Function}{:}{}
	\Comment{Key Generation}
	\Fn{\KeyGen$(1^k)$}{
		$p, q \gets$ random prime numbers of $k/2$ bits each \tcp*{Generate two primes}
		$N \gets p\times q$ \tcp*{Compute modulus}
		$\phi(N) \gets (p-1)(q-1)$ \tcp*{Compute Euler's phi function}
		$e \gets$ integer $e\in\of{1,\phi(N)}$ s.t. $\gcd(e, \phi(n)) = 1$ \tcp*{Choose encryption exponent}
		$d \gets$ integer $d\in\of{1,\phi(N)}$ s.t. $ed\equiv 1\pmod{\phi\of{N}}$ \tcp*{Compute decryption exponent}
		$\mathcolorbox{-green}{d_p\leftarrow d \mod p-1}$ \tcp*{Compute decryption exponent for $p$}
		$\mathcolorbox{-green}{d_q \leftarrow d \mod q-1}$ \tcp*{Compute decryption exponent for $q$}
		$q_{inv} \gets$ integer $q_{inv}\in(1, p-1)$ s.t. $qq_{inv}\equiv1 \pmod{p}$ \tcp*{Compute $q$ inverse modulo $p$}
		Set the $\rsa$ public key as $(N,e)$\;
		Set the $\rsa$ secret key as $(p,q,d_p,d_q,q_{inv})$\;
	}
	\textbf{End Function}\\
	\vspace{4pt}
	\vspace{4pt}
	\Comment{Encryption}
	\SetKwFunction{Enc}{Enc}
	\Fn{\Enc$(N,e,\mathcal{M})$}{
		$\mathcal{C}\gets\mathcal{M}^e\mod N$ \tcp*{Encrypt with $e$ and $N$}
	}
	\textbf{End Function}\\
	\vspace{4pt}
	\vspace{4pt}
	\Comment{Decryption}
	\SetKwFunction{Dec}{Dec}
	\Fn{\Dec$(\mathcal{C})$}{
		$m_1 \gets \mathcal{C}^{d_p} \mod p$ \tcp*{Decrypt with $d_p$ and $p$}
		$m_2 \gets \mathcal{C}^{d_q} \mod q$ \tcp*{Decrypt with $d_q$ and $q$}
		$t \gets q_{inv}(m_1 - m_2)$ \tcp*{Reconstruct the message using CRT}
		$m \leftarrow m_2 + qt\mod N$ \tcp*{$\mathcolorbox{-red}{m=(m_1-m_2)qq_{inv}+m_2\mod N}$}
		\KwRet{$m$}\;
	}
	\textbf{End Function}\\
	\vspace{2.5pt}
\end{algorithm}
\begin{proof}[Proof of Decryption]
	Given $d_p = d \mod (p-1)$, we have that $d = d_p + k(p - 1)$ for some integer $k$. Now, we are given the ciphertext $c = m^e \mod N$ and the decrypted message $m = c^d \mod N$. We want to show that $m_p = c^{d_p} \mod p$ is congruent to $m$ modulo $p$.
	
	Since $m = c^d \mod N$, we can rewrite it as $m \equiv c^d \pmod{p}$. Now, substitute the expression for $d$:
	
	$$m \equiv c^{d_p + k(p - 1)} \pmod{p}$$
	
	Using the properties of modular exponentiation, we can rewrite the equation as:
	
	$$m \equiv c^{d_p} \cdot c^{k(p - 1)} \pmod{p}$$
	
	Now, applying Fermat's Little Theorem, which states that for any prime number $p$ and integer $a$, if $a$ is not divisible by $p$, then $a^{p-1} \equiv 1 \pmod{p}$:
	
	$$c^{p-1} \equiv 1 \pmod{p}$$
	
	Using this result, we get:
	
	$$m \equiv c^{d_p} \cdot (c^{p - 1})^k \pmod{p}$$
	
	Since $c^{p-1} \equiv 1 \pmod{p}$, the equation becomes:
	
	$$m \equiv c^{d_p} \pmod{p}$$
	
	And as $m_p = c^{d_p} \mod p$, we have:
	
	$$m_p \equiv m \pmod{p}$$
	
	So, we can conclude that $m_p \equiv m \pmod{p}$.

\end{proof}


\newpage

RSA-CRT (Chinese Remainder Theorem) is a method for accelerating RSA decryption by using the CRT to combine the computations modulo the prime factors of the modulus. It is also possible to use the CRT to efficiently compute the RSA decryption function, as we will show.

Suppose we have an RSA public key $(N,e)$ and a private key $d$ such that $de \equiv 1 \pmod{\varphi(N)}$, where $\varphi(N) = (p-1)(q-1)$ is Euler's totient function evaluated at $N=pq$. Then for any ciphertext $c$ satisfying $0\leq c < N$, the plaintext $m$ is given by

$$ m \equiv c^d \pmod{N} $$

The RSA-CRT method involves computing $m$ modulo each prime factor of $N$, namely $p$ and $q$, and then combining these two values using the CRT to obtain the final value of $m$ modulo $N$. In other words, we first compute $m_p$ and $m_q$ such that

$$ m_p \equiv c^d \pmod{p} $$
$$ m_q \equiv c^d \pmod{q} $$

Using the fact that $p$ and $q$ are coprime, we can then use the CRT to find the unique value of $m$ modulo $N$ that satisfies both of these congruences:

$$ m \equiv m_p \pmod{p} $$
$$ m \equiv m_q \pmod{q} $$

We can compute $m$ using the following formula:

$$ m \equiv m_p + p((m_q - m_p)p^{-1}\bmod{q}) \pmod{N} $$

where $p^{-1}$ is the modular inverse of $p$ modulo $q$.

To prove that this formula gives the correct value of $m$, we can check that it satisfies both congruences above. First, we have

$$ m \equiv m_p + p((m_q - m_p)p^{-1}\bmod{q}) \equiv m_p \pmod{p} $$

by the definition of modular inverse. Similarly, we have

$$ m \equiv m_p + p((m_q - m_p)p^{-1}\bmod{q}) \equiv m_q \pmod{q} $$

since $(m_q - m_p)p^{-1}$ is divisible by $q$ by construction. Therefore, $m$ satisfies both congruences, and hence satisfies the original congruence $m \equiv c^d \pmod{N}$.

\newpage

	\section*{RSA Decryption Proof Using Group Theory}
	
	RSA is a widely-used public key cryptosystem that consists of encryption and decryption processes. In this section, we will provide a detailed proof of RSA decryption using group theory.
	
	\subsection*{Key Generation}
	First, let's briefly review the key generation process in RSA:
	
	\begin{enumerate}
		\item Choose two distinct prime numbers, $p$ and $q$.
		\item Compute $N = pq$.
		\item Calculate the Euler's totient function, $\phi(N) = (p - 1)(q - 1)$.
		\item Choose an integer $e$ such that $1 < e < \phi(N)$ and $\gcd(e, \phi(N)) = 1$.
		\item Compute $d \equiv e^{-1} \pmod{\phi(N)}$, the modular multiplicative inverse of $e$ modulo $\phi(N)$.
	\end{enumerate}
	
	The public key is $(N, e)$, and the private key is $(N, d)$.
	
	\subsection*{Encryption}
	Given a plaintext message $m$, the ciphertext $c$ is computed as follows:
	
	\[
	c \equiv m^e \pmod{N}
	\]
	
	\subsection*{Decryption}
	Given a ciphertext $c$, the decrypted message $m$ is computed as follows:
	
	\[
	m \equiv c^d \pmod{N}
	\]
	
	\subsection*{Proof of Correctness}
	To prove that decryption is correct, we need to show that the decrypted message $m$ is equal to the original plaintext message:
	
	\[
	(m^e)^d \equiv m \pmod{N}
	\]
	
	Let $G$ be the multiplicative group of integers modulo $N$:
	
	\[
	G = \{a \in \mathbb{Z}_N \mid \gcd(a, N) = 1\}
	\]
	
	We can observe that the order of $G$ is equal to the Euler's totient function $\phi(N)$. By the definition of the RSA cryptosystem, $e$ and $d$ are chosen such that $ed \equiv 1 \pmod{\phi(N)}$, which implies that $ed = 1 + k\phi(N)$ for some integer $k$. Thus, for any element $m \in G$, we have:
	
	\[
	m^{ed} = m^{1 + k\phi(N)} = m \cdot (m^{\phi(N)})^k
	\]
	
	By Euler's theorem, $m^{\phi(N)} \equiv 1 \pmod{N}$ for all $m \in G$, so we can conclude that:
	
	\[
	m^{ed} \equiv m \pmod{N}
	\]
	
	for all $m \in G$. However, if $m \notin G$, i.e., if $\gcd(m, N) \neq 1$, then $m$ must be divisible by one of the prime factors of $N$, either $p$ or $q$. Without loss of generality, let's assume that $m$ is divisible by $p$:
	
	\[
	m = p \cdot x
	\]
	
	for some integer $x$. Now, we can rewrite the equation as:
	
	\[
	m^{ed} \equiv (p \cdot x)^{ed} \equiv (p \cdot x) \pmod{N}
	\]
	
	In this case, both sides of the equation are divisible by $p$, so the congruence holds. Similarly, if $m$ is divisible by $q$, the congruence still holds.
	
	Thus, for all possible values of $m$, whether $m \in G$ or $m \notin G$, we have:
	
	$m^{ed}\equiv m\pmod{N}$
	This concludes the proof of RSA decryption correctness using group theory.

\footer{Department of Information Security, Cryptography and Mathematics, Kookmin University}
\end{document}