\documentclass[12pt,openany]{book}

\usepackage{amsmath,amsthm,amsfonts,amscd} % Packages for mathematics
\usepackage{multirow}
% Colors
\usepackage[dvipsnames]{xcolor}
\definecolor{titleblue}{RGB}{0,53,128}
\definecolor{chaptergray}{RGB}{140,140,140}
\definecolor{sectiongray}{RGB}{180,180,180}

\definecolor{thmcolor}{RGB}{231, 76, 60}
\definecolor{defcolor}{RGB}{52, 152, 219}
\definecolor{lemcolor}{RGB}{155, 89, 182}
\definecolor{corcolor}{RGB}{46, 204, 113}
\definecolor{procolor}{RGB}{241, 196, 15}
\definecolor{britishracinggreen}{rgb}{0.0, 0.26, 0.15}

% Fonts
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{newpxtext,newpxmath}
\usepackage{sectsty}
\allsectionsfont{\sffamily\color{titleblue}\mdseries}

% Page layout
\usepackage{geometry}
\geometry{a4paper,left=1.5in,right=1in,top=1in,bottom=1in,heightrounded}
\usepackage{fancyhdr}
\fancyhf{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[LO]{\nouppercase{\rightmark}}
\fancyhead[RE]{\nouppercase{\leftmark}}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}

% Chapter formatting
\usepackage{titlesec}
\titleformat{\chapter}[display]
{\normalfont\sffamily\Huge\bfseries\color{titleblue}}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titleformat{\section}
{\normalfont\sffamily\Large\bfseries\color{titleblue!100!gray}}{\thesection}{1em}{}
\titleformat{\subsection}
{\normalfont\sffamily\large\bfseries\color{titleblue!75!gray}}{\thesubsection}{1em}{}

% Table of contents formatting
\usepackage{tocloft}
\renewcommand{\cftchapfont}{\sffamily\color{titleblue}\bfseries}
\renewcommand{\cftsecfont}{\sffamily\color{chaptergray}}
\renewcommand{\cftsubsecfont}{\sffamily\color{sectiongray}}
\renewcommand{\cftchapleader}{\cftdotfill{\cftdotsep}}

% Hyperlinks
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=titleblue,
	filecolor=black,      
	urlcolor=titleblue,
}

%Listing
\usepackage{listings} %Code
\renewcommand{\lstlistingname}{Code}%

\definecolor{sagegreen}{rgb}{0.0,0.6,0.4}
\definecolor{sagepurple}{rgb}{0.6,0.0,0.4}
\definecolor{sageblue}{rgb}{0.0,0.4,0.6}
\definecolor{sageorange}{rgb}{1.0,0.4,0.0}
\definecolor{sagegray}{rgb}{0.4,0.4,0.4}

\lstdefinestyle{sage}{
	language=Python,
	backgroundcolor=\color{white},
	basicstyle=\small\ttfamily\color{black}, 
	basicstyle=\footnotesize\ttfamily\color{black},
	keywordstyle=\color{blue!60!black},
	commentstyle=\color{green!60!black},
	stringstyle=\color{purple!60!black},
	showstringspaces=false,
	breaklines=true,
	tabsize=4,
	morekeywords={True, False, None},
	frame=leftline, % Remove the border
	framesep=3pt,
	frameround=tttt,
	framexleftmargin=3pt,
	numbers=left,
	numberstyle=\small\color{gray},
	xleftmargin=15pt, % Increase the left margin
	xrightmargin=5pt,
	captionpos=b,
	belowskip=0pt,
	aboveskip=4pt
}

%Ceiling and Floor Function
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

%Algorithm
\usepackage[ruled,linesnumbered]{algorithm2e}
\usepackage{setspace}
\usepackage{algpseudocode}
\SetKwComment{Comment}{/* }{ */}
\SetKw{Break}{break}
\SetKw{Downto}{downto}
\SetKwProg{Fn}{Function}{:}{end}
\SetKwProg{Procedure}{procedure}{:}{end}
\SetKwProg{Construct}{Construct}{:}{end}
\SetKwFunction{KeyGen}{KeyGen}


%---------------------------My Preamble
\usepackage{booktabs}
\usepackage{multicol}
\setlength{\columnsep}{2cm}
\setlength{\columnseprule}{1.25pt}
\usepackage{enumerate}
\usepackage{soul}
\newcommand{\mathcolorbox}[2]{\colorbox{#1}{$\displaystyle #2$}}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{calc}
\usetikzlibrary{arrows,arrows.meta, positioning, shapes.multipart}

%Tcolorbox
\usepackage[most]{tcolorbox}
\tcbset{colback=white, arc=5pt}
%\tcbset{enhanced, colback=white,colframe=black,fonttitle=\bfseries,arc=4mm,boxrule=1pt,shadow={2mm}{-1mm}{0mm}{black!50}}
%White box with black text and shadow
%\begin{tcolorbox}[colback=white,colframe=black,fonttitle=\bfseries,title=Black Shadow Box,arc=4mm,boxrule=1pt,shadow={2mm}{-1mm}{0mm}{black!50}]
%	This is a white box with black text and a subtle shadow. The shadow adds some depth and dimension to the box without overpowering the design.
%\end{tcolorbox}

%Theorem
\newtheorem{axiom}{Axiom}[chapter]
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\newtheorem{remark}{Remark}[chapter]
\newtheorem{exercise}{Exercise}[chapter]
\newtheorem{example}{Example}[chapter]
\newtheorem*{note}{Note}

%New Command
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\nbhd}{\mathcal{N}}

\newcommand{\inv}[1]{#1^{-1}}

\newcommand{\ie}{\textnormal{i.e.}}
\newcommand{\eg}{\textnormal{e.g.}}

\newcommand{\of}[1]{\left( #1 \right)} 
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\norm}[1]{\left\| #1 \right\|}

\newcommand{\sol}{\textcolor{magenta}{\bf Sol}}

\newcommand{\img}{\operatorname{\textnormal{Img}}}
\newcommand{\id}{\operatorname{\textnormal{Id}}}

\newcommand{\dollar}{\$}
\newcommand{\uniform}{\xleftarrow{\dollar}}
\newcommand{\hash}{\mathsf{H}}

%Macro
\newcommand{\RSA}{\mathsf{RSA}}
\newcommand{\OAEP}{\mathsf{OAEP}}

\newcommand{\A}{\mathcal{A}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\oracle}{\mathcal{O}}
\newcommand{\ECB}{\mathsf{ECB}}
\newcommand{\OW}{\mathsf{OW}}
\newcommand{\IND}{\mathsf{IND}}
\newcommand{\PRF}{\mathsf{PRF}}
\newcommand{\PRP}{\mathsf{PRP}}
\newcommand{\PASS}{\mathsf{PASS}}
\newcommand{\CPA}{\mathsf{CPA}}
\newcommand{\CCA}{\mathsf{CCA}}
\newcommand{\CCATwo}{\mathsf{CCA2}}
\newcommand{\Adv}{\textnormal{Adv}}
\newcommand{\EncBlk}{\textnormal{EncBlk}}
\newcommand{\DecBlk}{\textnormal{DecBlk}}
\newcommand{\negl}{\textnormal{negl}}
\newcommand{\poly}{\textnormal{poly}}
\newcommand{\Time}{\textnormal{Time}}

\newcommand{\GenKey}{\mathsf{GenKey}}
\newcommand{\GenKeyPair}{\mathsf{GenKeyPair}}
\newcommand{\Encrypt}{\mathsf{Encrypt}}
\newcommand{\Decrypt}{\mathsf{Decrypt}}
\newcommand{\GenMacTag}{\mathsf{GenMacTag}}
\newcommand{\VerifyMacTag}{\mathsf{VerifyMacTag}}
\newcommand{\Sign}{\mathsf{Sign}}
\newcommand{\Verify}{\mathsf{Verify}}
\newcommand{\vaild}{\texttt{Valid}}
\newcommand{\invaild}{\texttt{Invalid}}

\newcommand{\OAEPEncode}{\mathsf{OAEPEncode}}
\newcommand{\OAEPDecode}{\mathsf{OAEPDecode}}

\renewcommand{\mod}{\operatorname{\textnormal{mod}}}


% Begin document
\begin{document}
	
	% Title page
	\begin{titlepage}
		\begin{center}
			{\Huge\textsf{\textbf{Public Key Cryptography}}\par}
			\vspace{0.5in}
			{\Large Ji Yong-Hyeon\par}
			\vspace{1in}
			\begin{tikzpicture}
			\draw (0,0) circle (1cm);
			\node at (0,0) {Data};
			
			\draw (2,0) circle (0.5cm) node {Key 1} -- (1,0);
			\draw [->] (2.5,0) -- (3.5,0);
			\draw (4,0) circle (0.5cm) node {Key 2};
			
			\draw [->] (0.5,0) -- (-0.5,0);
			\draw (-1,0) circle (0.5cm) node {Key 3};
			
			\node [above] at (2.5,0.5) {Public Key};
			\node [above] at (-0.5,0.5) {Private Key};
			\end{tikzpicture}\par
			%\includegraphics[width=3in]{algebra.png}\par
			\vspace{1in}
			{\large Ji Yong-Hyeon\par}
			{\large \today\par}
		\end{center}
	\end{titlepage}
	
	% Table of contents
	\tableofcontents
	
	% Chapters
	\mainmatter
	
	\chapter{Public Key Cryptography in a Nutshell: Classification and Security Notions}
	
	\section{PKE}
	Signature, Key Establishment
	
	Onewayness Trapdoor, IND-CCA2, EUF-CMA
	
	
	\newpage
	\chapter{IFP-based Primitives}
	
	\section{Textbook RSA}
	
	RSA is a public-key cryptosystem that uses the mathematics of prime numbers to secure communication over the internet. It is widely used in various applications, such as digital signatures, secure email, and online banking.
	
	The RSA cryptosystem is based on the following mathematical concepts:
	
	
	\begin{itemize}
		\item Modular arithmetic:
		- a mod b (remainder when a is divided by b)
		- Euler's totient function phi(n) (number of positive integers less than n that are coprime to n)
		\item Prime factorization:
		- finding the unique prime factors of a given integer
		\item The Chinese Remainder Theorem:
		- a theorem that provides a solution to a system of linear congruences with pairwise relatively prime moduli
		\item Fermat's Little Theorem:
		- a theorem that states that if p is a prime number and a is an integer not divisible by p, then $a^{(p-1)}$ is congruent to 1 modulo p.
		\item Euler's Theorem:
		- a generalization of Fermat's Little Theorem that states that if a and n are coprime, then $a^{(\phi(n))}$ is congruent to 1 modulo n.
	\end{itemize}
	
	\subsection{The RSA Algorithm}
	
	\subsubsection{Key Generation}
	To generate an RSA key pair, we follow these steps:
	\begin{enumerate}
		\item Choose two large prime numbers $p$ and $q$.
		\item Compute $n = pq$ and $\phi(n) = (p-1)(q-1)$.
		\item Choose an integer $e$ such that $1 < e < \phi(n)$ and $\gcd(e, \phi(n)) = 1$.
		\item Compute $d$ such that $de \equiv 1 \pmod{\phi(n)}$.
	\end{enumerate}
	The public key is $(n, e)$, and the private key is $d$.
	
	\subsubsection{Encryption}
	To encrypt a message $M$, we use the public key $(n, e)$ and compute:
	$$C = M^e \pmod{n}$$
	The ciphertext $C$ is then sent to the recipient.
	
	\subsubsection{Decryption}
	To decrypt the ciphertext $C$, we use the private key $d$ and compute:
	$$M = C^d \pmod{n}$$
	The plaintext $M$ is then recovered.
	
	\subsection{Security}
	RSA is secure because it is based on the difficulty of factoring large integers. If an attacker can factor $n$ into its prime factors $p$ and $q$, then they can compute $\phi(n)$ and derive the private key. However, factoring large numbers is currently considered computationally infeasible, making RSA a secure choice for many applications.
	
	\subsection{Conclusion}
	RSA is a widely used public-key cryptosystem that uses prime numbers to secure communication over the internet. It is based on the difficulty of factoring large integers and is currently considered secure for many applications.
	
	
	\section{RSA-CRT}
	
	RSA-CRT is a modified version of the RSA public-key cryptosystem that leverages the Chinese Remainder Theorem to enhance the speed of the decryption process.
	
	RSA-CRT works by first generating two large primes, $p$ and $q$, and computing the modulus $n=pq$. Then, the public and private keys are generated using the usual RSA key generation algorithm.
	
	When encrypting a message, the sender uses the recipient's public key to encrypt the message, as in standard RSA. However, when decrypting a message, the recipient first computes two intermediate values, $m_1$ and $m_2$, using the Chinese Remainder Theorem. These values are then combined to obtain the original message.
	
	The Chinese Remainder Theorem states that given a system of linear congruences with pairwise relatively prime moduli, there exists a unique solution modulo the product of the moduli. In the case of RSA-CRT, the two moduli are $p$ and $q$, which are both primes, and the system of congruences is:
	
	$$\begin{aligned} m \equiv c^d \pmod{p}\ m \equiv c^d \pmod{q}\end{aligned}$$
	
	where $c$ is the encrypted message, $d$ is the recipient's private key, and $m$ is the decrypted message.
	
	The two intermediate values, $m_1$ and $m_2$, are computed as:
	
	$$\begin{aligned} m_1 &\equiv c^d \pmod{p}\ m_2 &\equiv c^d \pmod{q}\end{aligned}$$
	
	These values can be computed efficiently using modular exponentiation, which is much faster than using the standard RSA decryption algorithm to compute $m$ directly.
	
	Finally, the original message can be recovered by combining $m_1$ and $m_2$ using the Chinese Remainder Theorem:
	
	$$m \equiv m_1 + q((m_2 - m_1)q^{-1} \bmod p) \pmod n$$
	
	where $q^{-1}$ is the modular inverse of $q$ modulo $p$. This formula allows the recipient to efficiently compute the original message without having to compute the expensive modular exponentiation step for the entire modulus $n$.
	
	\begin{tcolorbox}[colback=white!10!white,colframe=blue!50!black,title=RSA-CRT Algorithm]
		\begin{enumerate}
			\item Generate two large primes $p$ and $q$, and compute $n = pq$.
			\item Generate the public and private keys using the usual RSA key generation algorithm. That is, \begin{enumerate}
				\item Compute the totient of n, $\phi(n) = (p - 1)(q - 1)$.
				\item Choose an integer $e$ such that \[
				1 < e < \phi(n)\quad \text{and}\quad \gcd(e, \phi(n)) = 1.
				\] This is the public key exponent.
				\item Compute the private key exponent $d$ such that \[
				d\equiv\inv{e} \pmod{\phi(n)}.
				\] This can be done efficiently using the Extended Euclidean Algorithm.
			\end{enumerate}
			The public key is $(n, e)$, and the private key is $(n, d)$.
			\item To encrypt a message $\mathcal{M}$, use the recipient's public key to compute \[
			\mathcal{C} = \mathcal{M}^e \mod{n}.
			\]
			\item To decrypt a message $\mathcal{C}$, compute the two intermediate values: \begin{enumerate}
				\item $m_1 = \mathcal{C}^d \mod p$.
				\item $m_2 = \mathcal{C}^d \mod q$.
			\end{enumerate}
			\item Combine the two intermediate values using the Chinese Remainder Theorem to obtain the original message $\mathcal{M}$: \[
			\mathcal{M} = m_1+q\of{\of{m_2-m_1}\inv{q}\mod p}\pmod{n}.
			\]
		\end{enumerate}
	\end{tcolorbox}
	
	\begin{tcolorbox}[title=Chinese Remainder Theorem]
		\begin{theorem}
			Given a system of linear congruences with pairwise relatively prime moduli:
			\begin{align*}
			x&\equiv a_1 \pmod{m_1}\\
			x&\equiv a_2 \pmod{m_2}\\
			&\vdots \\
			x&\equiv a_n \pmod{m_1},
			\end{align*}
			
			there exists a unique solution $x$ modulo $M = m_1m_2\cdots m_n$:
			\begin{align*}
			x&\equiv a_1b_1M_1+a_2b_2M_2+\cdots a_nb_nM_n\pmod{M}, \ie,\\ x&\equiv\sum_{i=1}^{n}a_ib_iM_i\pmod{M}
			\end{align*}\[
			\] where $M_i=M/m_i$ and $b_i$ is the inverse of $M_i$ modulo $m_i$.
		\end{theorem}
	\end{tcolorbox}
	
	\section{Fermat's Little Theorem}
	
	\begin{tcolorbox}[title=Fermat's Little Theorem]
		\begin{theorem}
			Let $p$ is a prime number and $a$ is an integer not divisible by $p$, then \[
			a^{p-1}\equiv1 \pmod{p}.
			\] In other words, if we take any non-zero integer $a$ and raise it to the power $p-1$, then divide the result by a prime $p$, the remainder will always be 1. This theorem is widely used in number theory and cryptography.
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		We use mathematical induction and binomial theorem. \begin{enumerate}
			\item (Basic Step) Let $a=1$, then $1^{p-1}=1\equiv\pmod{p}$, which is true.
			\item (Inductive Step) Suppose that the theorem holds for some integer $a$. We need to show that it also holds for $a+1$. We can express $(a+1)^{p}$ as: \[
			\of{a+1}^p=\sum_{i=0}^{p}\binom{p}{i}a^{i} 1^{p-i}
			\]
		\end{enumerate}
	\end{proof}
	Using the binomial theorem. Since $p$ is a prime number, we know that $\binom{p}{i}$ is divisible by $p$ for $0<i<p$, hence:
	
	$$(a+1)^{p} \equiv a^{p} + 1^{p} \equiv a + 1 \pmod{p}$$
	
	The last step follows from the fact that $a^{p-1} \equiv 1 \pmod{p}$. Therefore, we have shown that:
	
	$$(a+1)^{p-1} \equiv 1 \pmod{p}$$
	
	which completes the proof of Fermat's Little Theorem.
	
	\begin{proof}
		We use the group theory of the multiplicative group of integers modulo a prime $p$.
		
		Let $p$ be a prime number, and let $a$ be an integer that is not divisible by $p$. Consider the set of integers modulo $p$, denoted by $\mathbb{Z}/p\mathbb{Z}$. This set forms a group under multiplication, denoted by $(\mathbb{Z}/p\mathbb{Z})^{\times}$. Since $p$ is prime, the group $(\mathbb{Z}/p\mathbb{Z})^{\times}$ has order $p-1$, which means that it contains $p-1$ distinct elements.
		
		Now consider the subset of $(\mathbb{Z}/p\mathbb{Z})^{\times}$ consisting of the multiples of $a$, denoted by $S_a = {a, 2a, 3a, \ldots, (p-1)a}$. Since $a$ is not divisible by $p$, the set $S_a$ consists of distinct elements. We claim that $S_a$ is a permutation of the elements of $(\mathbb{Z}/p\mathbb{Z})^{\times}$.
		
		To prove this claim, we need to show that every element of $(\mathbb{Z}/p\mathbb{Z})^{\times}$ can be expressed as a multiple of $a$ modulo $p$. Suppose for the sake of contradiction that there exists an element $b \in (\mathbb{Z}/p\mathbb{Z})^{\times}$ that cannot be expressed as $b = ka \pmod{p}$ for any integer $k$. Then the integers $1a, 2a, \ldots, (p-1)a$ would not be distinct modulo $p$, which contradicts our assumption that $S_a$ consists of distinct elements. Therefore, $S_a$ is a permutation of the elements of $(\mathbb{Z}/p\mathbb{Z})^{\times}$.
		
		Since $S_a$ is a permutation of the elements of $(\mathbb{Z}/p\mathbb{Z})^{\times}$, we can multiply all the elements of $S_a$ together to obtain:
		
		$$a \cdot 2a \cdot \ldots \cdot (p-1)a \equiv 1 \cdot 2 \cdot \ldots \cdot (p-1) \pmod{p}$$
		
		which simplifies to:
		
		$$(p-1)!a^{p-1} \equiv (p-1)! \pmod{p}$$
		
		Since $p$ does not divide $(p-1)!$, we can cancel out $(p-1)!$ from both sides to obtain:
		
		$$a^{p-1} \equiv 1 \pmod{p}$$
		
		This completes the proof of Fermat's Little Theorem using the theory of abstract algebra.
	\end{proof}
	
	\newpage
	\section{Euler's Theorem}
	
	Euler's Theorem is a generalization of Fermat's Little Theorem. It states that if $a$ and $n$ are two positive integers that are coprime, then:
	
	$$a^{\varphi(n)} \equiv 1 \pmod{n}$$
	
	where $\varphi(n)$ is Euler's totient function, which gives the number of positive integers less than or equal to $n$ that are coprime with $n$. Euler's Theorem is useful in cryptography for testing the primality of large numbers and for computing modular exponentiations efficiently.
	
	Proof: We can prove Euler's Theorem using the fact that the totient function is multiplicative, which means that if $m$ and $n$ are two coprime positive integers, then:
	
	$$\varphi(mn) = \varphi(m) \varphi(n)$$
	
	We can use this property to reduce the theorem to the case where $n$ is a prime power $p^k$, where $p$ is a prime and $k$ is a positive integer. If $k=1$, then Euler's Theorem reduces to Fermat's Little Theorem. Otherwise, we can use the Chinese Remainder Theorem to combine the solutions of $a^{\varphi(p^k)} \equiv 1 \pmod{p^k}$ for all prime powers $p^k$ that divide $n$. Since the exponents $\varphi(p^k)$ are powers of $p$, we can use repeated squaring to compute the modular exponentiations efficiently. This completes the proof of Euler's Theorem.
	
	\begin{proof}
		Euler's Theorem is a generalization of Fermat's Little Theorem and states that if $a$ and $n$ are two coprime positive integers, then
		
		$$a^{\varphi(n)} \equiv 1 \pmod{n}$$
		
		where $\varphi(n)$ is Euler's totient function, which gives the number of positive integers less than or equal to $n$ that are coprime with $n$.
		
		To prove Euler's Theorem, we first define a group $G$ of integers modulo $n$ that are coprime with $n$. This group is denoted as:
		
		$$G = {a \in \mathbb{Z}_n | gcd(a,n)=1}$$
		
		Next, we define the function $f(a) = ra \pmod{n}$ where $r$ is a fixed integer coprime with $n$. It can be shown that $f$ is a permutation of $G$ and that the order of the group $G$ is $\varphi(n)$.
		
		Now, we consider the product of all elements in $G$:
		
		$$P = \prod_{a \in G} f(a) = \prod_{a \in G} ra \pmod{n}$$
		
		We can rewrite this product as:
		
		$$P = r^{\varphi(n)} \prod_{a \in G} a \pmod{n}$$
		
		Since $a$ is coprime with $n$, we know that $a$ has a unique inverse $b$ in the group $G$ such that $ab \equiv 1 \pmod{n}$. Therefore, we can rewrite the product as:
		
		$$P = r^{\varphi(n)} \prod_{a \in G} a \prod_{a \in G} b = r^{\varphi(n)} \prod_{a \in G} 1 = r^{\varphi(n)}$$
		
		where we used the fact that $ab \equiv 1 \pmod{n}$ and that $a$ and $b$ are both in the group $G$.
		
		On the other hand, we can rearrange the terms in the product as:
		
		$$P = \prod_{a \in G} f(a) = \prod_{a \in G} (ar) \pmod{n} = r^{\varphi(n)} \prod_{a \in G} a \pmod{n}$$
		
		where we used the fact that $ar$ is also in the group $G$ since $r$ is coprime with $n$.
		
		Equating the two expressions for $P$, we get:
		
		$$r^{\varphi(n)} \prod_{a \in G} a \equiv r^{\varphi(n)} \prod_{a \in G} a \pmod{n}$$
		
		Dividing both sides by $\prod_{a \in G} a$, we obtain:
		
		$$r^{\varphi(n)} \equiv 1 \pmod{n}$$
		
		which is Euler's Theorem.
	\end{proof}
	
	\section{Primality Test}
	
	A primality test is a method used to determine if a given positive integer is a prime number or a composite number. There are various primality tests, and they differ in their speed, accuracy, and the range of numbers they can handle.
	
	One of the simplest and most well-known primality tests is the trial division method. This method involves dividing the number by each integer from 2 up to the square root of the number, checking if any of the divisors evenly divide the number. If no divisor is found, then the number is prime. However, this method becomes impractical for very large numbers, as the number of potential divisors to check grows with the number being tested.
	
	Another primality test is the Fermat primality test. This test is based on Fermat's Little Theorem, which states that if $p$ is a prime number and $a$ is any integer not divisible by $p$, then $a^{p-1} \equiv 1 \pmod p$. The Fermat primality test uses this theorem to check if a number is prime by randomly selecting values of $a$ and checking if the equation holds for each value. If the equation fails for any $a$, then the number is composite. If the equation holds for many values of $a$, the number is likely prime, but there is still a small chance it could be composite.
	
	The Miller-Rabin primality test is a more sophisticated primality test that is based on the same idea as the Fermat test but is more efficient and has a higher probability of correctly identifying composite numbers. The Miller-Rabin test involves selecting a random value $a$ and then repeatedly squaring it and checking if the resulting values satisfy the equation $a^{d} \equiv 1 \pmod n$ or $a^{2^rd} \equiv -1 \pmod n$ for some values of $r$ and $d$. If the equation holds for many values of $r$ and $d$, the number is likely prime, but if the equation fails for any $r$ or $d$, the number is composite.
	
	There are also deterministic primality tests that can determine with certainty whether a number is prime or composite. One example is the AKS primality test, which is based on a polynomial-time algorithm and can handle very large numbers. However, deterministic tests are generally more complex and slower than probabilistic tests.
	
	\newpage
	\chapter{Integer Factorization Problem}
	
	\section{Pollard's $p-1$ Method}
	Pollard's $p-1$ method is an algorithm for factoring a composite number $N$ when one of its prime factors, $p$, has a small prime factor in $p-1$. The method is based on Fermat's Little Theorem and relies on the properties of the greatest common divisor (GCD) function.
	\vspace{4pt}\\
	\begin{algorithm}[H]
		\caption{Pollard's $p-1$ Method}
		\label{algo:pollard_p-1}
		\KwData{An integer $N=pq$ which is the product of two primes $p$ and $q$.}
		\KwResult{$(p,q)$ or \texttt{Failure}.}
		
		\BlankLine
		$k_1,k_2\gets\mathbb{Z}^+$ \tcp*{Choose two bounds}
		$i\gets 0$\;
		\While{$i<k_1$}{
			$a\uniform \left(1,\sqrt{N}\right)$ \tcp*{Initialization}
			\If{$1<\gcd\of{a,N}<N$}{
				\Return{$\displaystyle\of{\gcd\of{a,N},\frac{N}{\gcd\of{a,N}}}$}\;
			}
			$j\gets 2$ \tcp*{$\gcd\of{a,N=pq}=1$}
			\While{$j<k_2$}{
				$a \gets a^j \mod N$\;
				$d \gets \gcd(a - 1, N)$\;
				\uIf{$1 < d < N$}{
					\Return{$(d,N/d)$}\;
				}\ElseIf{$d = N$}{
					\textbf{Goto} line 19\;
				}
				$j\to j+1$\;
			}
			$i\gets i+1$\;
		}
		\Return{\texttt{Failure}}\;
	\end{algorithm}
	
	\subsection{The multiple of $p-1$}
	Fermat's Little Theorem states that if $p$ is a prime number and $a$ is an integer not divisible by $p$, then
	\[
	a^{p-1} \equiv 1 \pmod{p}.
	\]
	Let $N = pq$, and let $a\uniform[1,p-1]$. Consider an integer $k$ such that $k=(p-1)t$ for some $t\in\Z$, that is, a multiple of $p-1$, then
	\[
	a^k =\of{a^{p-1}}^t\equiv 1 \pmod{p}.
	\]
	Then \begin{align*}
	a^k - 1 \equiv 0 \pmod{p}&\implies p \mid (a^k - 1)\\
	&\implies \gcd\of{a^k-1, N}\in\set{p,N=pq}.
	\end{align*} If $\gcd\of{a^k-1,N}\neq N$ then \[
	N=p\times q=\gcd\of{a^k-1,N}\times\frac{N}{\gcd\of{a^k-1,N}}.
	\]
	\hl{Pollard's $p-1$ method aims to find such an integer $k$ is a multiple of $p-1$}.
	\vspace{8pt}
	\iffalse
	\begin{remark}
		Consider $\square\uniform\of{0,\ceil*{\sqrt{N}}}$. Then either $1<\gcd\of{\square,N}<N$ or $\gcd\of{\square,N}=1$.
		\begin{itemize}
			\item[] ($\gcd\of{\square,N}\in(1,N)$) Clearly, $N=\gcd\of{\square, N}\times\frac{N}{\gcd\of{\square, N}}$.
			\item[] ($\gcd\of{\square,N}=1$) Since $\left[\gcd\of{\square,N}=1\Rightarrow\gcd\of{\square^k,N}=1\right]$,
		\end{itemize}
	\end{remark}
	\fi
	\subsection{How to find the multiple of $p-1$}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf Existence of the Multiple of $p-1$}]
		\begin{lemma}
			Let $p$ be a prime. Then \[
			\exists n_0\in\N:\left[n\geq n_0\implies p-1\mid n!\right].
			\]
		\end{lemma}
	\end{tcolorbox}
	\begin{proof}
		Define a set $S$ by \[
		S:=\set{k\in\N:k!\equiv0\pmod{p-1}}.
		\] Since $\of{p-1}!\equiv 0\pmod{p-1}$, we know $p-1\in S$, \ie, $S\neq\emptyset$. By well-ordering principle, $\exists\min S=:n_0$. Since $n_0\in S$, $n_0!\equiv 0\pmod{p-1}$ holds.
		
		We want to show that $n\geq n_0\implies p-1\mid n!$. Let $n\geq n_0$ then $n=n_0+k$ for some $k\in\Z_{\geq 0}$. Now, consider the factorial of $n$: \[
		n!=\of{n_0+k}!=\of{n_0+k}\of{n_0+k-1}\cdots\of{n_0+1}n_0!.
		\] Thus, \[
		n_0!\equiv 0\pmod{p-1}\implies p-1\mid n_0!\implies p-1\mid \underbrace{n_0!\of{n_0+1}\cdots\of{n_0+k}}_{=\of{n_0+k}!=n!}.
		\]
	\end{proof}
	
	\begin{example}
		Consider the prime $65537=2^{16}+1$. Then \begin{align*}
		15!(=2^{11}\cdot 3^6\cdot 5^3\cdot 7^2\cdot 11\cdot 13)\mod 2^{16} &= 22528&\Rightarrow p-1\nmid 15!,\\
		16!(=2^{15}\cdot 3^6\cdot 5^3\cdot 7^2\cdot 11\cdot 13)\mod 2^{16} &= 32768&\Rightarrow p-1\nmid 16!,\\
		17!(=2^{15}\cdot 3^6\cdot 5^3\cdot 7^2\cdot 11\cdot 13\cdot 17)\mod 2^{16} &= 32768&\Rightarrow p-1\nmid 17!,\\
		18!(=2^{16}\cdot 3^8\cdot 5^3\cdot 7^2\cdot 11\cdot 13\cdot 17)\mod 2^{16} &= 0&\Rightarrow p-1\mid 18!,\\
		19!(=2^{16}\cdot 3^8\cdot 5^3\cdot 7^2\cdot 11\cdot 13\cdot 17\cdot 19)\mod 2^{16} &= 0&\Rightarrow p-1\mid 19!.
		\end{align*} Thus, arbitrarily choose a value for $a$, then increment $j$ from $1$, and check if the value of $\gcd\of{a^{j!}-1,N}\in(1,N)$:
		\begin{align*}
		1<\gcd(a^{1!}&-1,N)<N?\\
		1<\gcd(a^{2!}&-1,N)<N?\\
		1<\gcd(a^{3!}&-1,N)<N?\\
		&\vdots
		\end{align*}
		If $gcd(a^{j!} - 1, N) = N$, then $gcd(a^{(j+1)!} - 1, N)$ also equals $N$, so the test is stopped, a new value for $a$ is chosen, and the test proceeds.
	\end{example}
	\vspace{8pt}
	\begin{tcolorbox}[colback=white,colframe=procolor,arc=5pt,title={\color{white}\bf Existence of the Multiple of $p-1$}]
		\begin{proposition}
			\[
			\gcd\of{a^{j!}-1,N}=N\implies\gcd\of{a^{\of{j+1}!}-1,N}=N.
			\]
		\end{proposition}
	\end{tcolorbox}
	\begin{proof}
		Since \begin{align*}
		\gcd\of{a^{j!}-1,N}=N&\implies N\mid a^{j!}-1\\
		&\implies a^{j!}\equiv 1\pmod{N}\\
		&\implies \of{a^{j!}}^{j+1}\equiv 1\pmod{N}\\
		&\implies N\mid a^{\of{j+1}!}-1\\
		&\implies a^{\of{j+1}!}-1=Nk\quad \text{for some}\quad k\in\Z,
		\end{align*} we have \[
		\gcd\of{a^{\of{j+1}!}-1,N}=\gcd\of{Nk,N}=N.
		\]
	\end{proof}
	
	\subsection{How to compute $\gcd\of{a^{n!}-1,N}$ efficiently}
	
	\begin{tcolorbox}[colback=white,colframe=procolor,arc=5pt,title={\color{white}\bf Existence of the Multiple of $p-1$}]
		\begin{proposition}
			\begin{align*}
			\gcd\of{a^{\of{j+1}!}-1,N}&=\gcd\of{a^{\of{j+1}!}\mod N-1,N}\\
			&=\gcd\of{\of{a^{j!}\mod N}^{j+1}-1,N}.
			\end{align*}
		\end{proposition}
	\end{tcolorbox}
	\begin{remark}
		We can compute $\gcd\of{a^{n!}-1,N}$ as follows: \begin{align*}
		a_0&=a&\\
		a_1&=a^{1!}\mod N=a_0^1\mod N&\Rightarrow 1<\gcd\of{a_1-1,N}<N?\\
		a_2&=a^{2!}\mod N=a_1^2\mod N&\Rightarrow 1<\gcd\of{a_2-1,N}<N?\\
		a_3&=a^{3!}\mod N=a_2^3\mod N&\Rightarrow 1<\gcd\of{a_3-1,N}<N?\\
		&\vdots &
		\end{align*}
	\end{remark}
	\vspace{8pt}
	\begin{example}
		Factor $N=5157437$ using Pollard $p-1$ method.\begin{proof}[\sol]
			content...
		\end{proof}
	\end{example}
	
	
	\begin{exercise}
		Factor $N=221$ using Pollard $p-1$ method.\begin{proof}[\sol]
			content...
		\end{proof}
	\end{exercise}
	
	\subsection{Special Case I}
	Assume that $a^k\mod p = 1$. Then \[
	p\mid a^k-1\implies \gcd\of{a^t-1,pq}\in\set{p,pq}.
	\]
	
	
	\subsection{Special Case II}
	Assume that $p-1\mid n!$ and $q-1\mid n!$.
	
	
	\newpage
	\section{Fermat Factorization}
	\subsection{Fermat Factorization ($N=a^2-b^2$)}
	
	\begin{algorithm}[H]
		\caption{Fermat Factorization: $N=a^2-b^2$}
		\KwData{$N=pq$, $B\in\Z_{>0}$.}
		\KwResult{$(p,q)$ or \texttt{Failure}}
		\BlankLine
		\For{$b=1$ \KwTo $B$}{
			$t\gets N+b^2$\;
			\If{$t$ is a square}{
				$a\gets\sqrt{t}$\;
				\Return $\of{a-b,a+b}$\;
			}
		}
		\Return \texttt{Failure}\;
	\end{algorithm}
	\begin{example}
		Factor 6077 using Fermat method.
		\begin{proof}[\sol]
			Note that $\ceil*{\sqrt{6077}}=78$. Then \begin{align*}
			78^2-6077&=7\\
			&\vdots\\
			81^2-6077&=484=22^2.
			\end{align*}
			Thus, $6077=\of{81+22}\of{81-21}=103\cdot 59$.
		\end{proof}
	\end{example}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		\begin{lemma}
			Let $n\in 2\Z+1$. Define two sets: \begin{align*}
			S_n&:=\set{(a,b)\in\Z^2:n=ab\ \text{with}\ 0<b\leq a},\\
			T_n&:=\set{\of{u^2,v^2}\in\Z^2:n=u^2-v^2}.
			\end{align*} Then $\exists\phi:S_n\leftrightarrow T_n$. In other words, there exists a one-to-one correspondence between factorizations of $n$ into two positive integers and differences of two squares that equal $n$.
		\end{lemma}
	\end{tcolorbox}
	\begin{proof}
		Define two functions: \begin{align*}
		f:S_n\to T_n&:f\of{\of{a,b}}=\of{\of{\frac{a+b}{2}}^2,\of{\frac{a-b}{2}}^2},\\
		g:T_n\to S_n&:g\of{\of{u^2,v^2}}=\of{\abs{u}+\abs{v},\abs{u}-\abs{v}}.
		\end{align*} We claim that $g\circ f=\id_{S_n}$ and $f\circ g=\id_{T_n}$:\begin{align*}
		\of{g\circ f}(a,b)&=g\of{\of{\frac{a+b}{2}}^2,\of{\frac{a-b}{2}}^2}=\of{\abs{\frac{a+b}{2}}+\abs{\frac{a-b}{2}},\abs{\frac{a+b}{2}}-\abs{\frac{a-b}{2}}}\\
		&=\of{{\frac{a+b}{2}}+{\frac{a-b}{2}},{\frac{a+b}{2}}-{\frac{a-b}{2}}}\\
		&=\of{a,b},\\
		\of{f\circ g}\of{u^2,v^2}&=f\of{\abs{u}+\abs{v},\abs{u}-\abs{v}}=\of{\abs{u}^2,\abs{v}^2}=\of{u^2,v^2}.
		\end{align*}
	\end{proof}
	
	\subsection{Improved Fermat Factorization ($rN=a^2-b^2$)}
	
	Let $N=pq$ and $r<\min\set{p,q}$.
	
	\begin{algorithm}[H]
		\caption{Improved Fermat Factorization: $rN=a^2-b^2$}
		\KwData{$N=pq$, $R\in\of{0,\min\set{p,q}}\setminus\set{2}$ and $B\in\Z_{>0}$.}
		\KwResult{$(p,q)$ or \texttt{Failure}}
		\vspace{4pt}
		\vspace{4pt}
		\For{$r=1$ \KwTo $R$}{
			\For{$b=1$ \KwTo $B$}{
				$t\gets rN+b^2$\;
				\If{$t$ is a square}{
					$a\gets\sqrt{t}$\;
					$d\gets\gcd\of{N,a-b}$\;
					\If{$1<d<N$}{
						\Return $\of{d,N/d}$\;
					}
				}
			}
		}
		\Return \texttt{Failure}\;
	\end{algorithm}
	\begin{remark}
		Let $N\in 2\Z+1$ and $b\in\Z^+$. Then $2N+b^2$ is not square.
		\begin{proof}
			Note that, for any square number $\alpha$, $\alpha\mod 4\in\set{0,1}$ since \begin{align*}
			\of{2k}^2&=4k^2\equiv 0\pmod{4}\\
			\of{2k+1}^2&=4k^2+4k+1\equiv 1\pmod{4}.
			\end{align*} Let $N=2m+1$ then \begin{itemize}
				\item[] (Case 1) ($b=2n$) \[
				2N+b^2=(4m+2)+4n^2\equiv 2\pmod{4}.
				\]
				\item[] (Case 2) ($b=2n+1$) \[
				2N+b^2=(4m+2)+(4n^2+4n+1)\equiv 3\pmod{4}.
				\]
			\end{itemize} Thus, $2N+b^2\mod 4\in\set{2,3}$, and hence $2N+b^2$ is not square.
		\end{proof}
	\end{remark}
	
	\newpage
	\section{Pollard's $\rho$ Method for IFP}
	
	Pollard's Rho algorithm is a probabilistic factorization algorithm that is particularly effective in finding small factors of large composite numbers. Given a composite number $N$, the algorithm aims to find a non-trivial factor $p$ of $N$.
	
	The algorithm is not deterministic, meaning it may not always find a factor in a fixed number of steps. However, it has an expected running time of $O(\sqrt{p})$, where $p$ is the smallest prime factor of $N$, making it an efficient algorithm for finding small factors.
	
	Finding $a$ and $b$ that satisfy $rN=a^2-b^2$ is equivalent to finding $a$ and $b$ satisfying \begin{center}
		(i) $a^2\equiv b^2\pmod{N}$,\quad (ii) $\gcd\of{N,a-b}\in\of{1,N}$.
	\end{center}
	Using Floyd's cycle-finding, we can find $a$ and $b$ satisfying above equation.
	
	Define a function $f_{N,c}:\Z_N\to\Z_N$ as follows: \[
	f_{N,c}\of{X}:=X^2+c\mod{N}.
	\]
	
	\begin{tcolorbox}[colback=white,colframe=procolor,arc=5pt,title={\color{white}\bf }]
		\begin{proposition}
			A sequence $\set{a_n^{(p)}}:=\set{a_n\mod p}$ satisfies \[
			a_i^{(p)}=
			a_j^{(p)}\implies
			a_{i+1}^{(p)}=
			a_{j+1}^{(p)}
			\]
		\end{proposition}
	\end{tcolorbox}
	\begin{proof}
		\begin{align*}
		a_i^{(p)}=a_j^{(p)}\Leftrightarrow a_i\mod p=a_j\mod p
		&\Leftrightarrow a_i\equiv a_j\pmod{p}\\
		&\Leftrightarrow a_i^2+c\equiv a_j^2+c\pmod{p}\\
		&\Leftrightarrow \of{a_i^2+c\mod pq}\mod p=\of{a_j^2+c\mod pq}\mod p\\
		&\Leftrightarrow a_{i+1}\mod p=a_{j+1}\mod p\\
		&\Leftrightarrow a_{i+1}^{(p)}= a_{j+1}^{(p)}.
		\end{align*}
	\end{proof}
	
	\begin{algorithm}[H]
		\caption{Pollard's $\rho$ Method for IFP}
		\KwData{$N=pq$ ($p,q$: distinct odd primes), $c\uniform\Z_N$: constant.}
		\KwResult{$p$ and $q$.}
		\BlankLine
		$(a,b)\gets\of{2,2}$\;
		\vspace{4pt}
		\While{\texttt{True}}{
			$\of{a,b}\gets\of{f\of{a},\of{f\circ f}\of{b}}$\tcp*{$f(x):=x^2+c\mod N$}
			$d\gets\gcd\of{N,a-b}$\;
			\If{$1<d<N$}{
				\Return $\of{d, N/d}$\;
			}
		}
	\end{algorithm}
	
	\chapter{Birthday Attack}
	The birthday problem (also known as the birthday paradox) is a famous problem in probability theory that demonstrates the surprising fact that, in a group of just 23 people, there is a greater than 50\% chance that at least two of them share the same birthday. It is based on the assumption that birthdays are uniformly distributed throughout the year (ignoring leap years).
	
	\section{Birthday Bound}
	Let $n$ be the number of people in the group. Consider \[
	a_1,\cdots,a_k\uniform\set{1,\cdots, n}
	\] with $k\leq n$. Let $P(n)$ be the probability that at least two people share a birthday: \[
	P\of{n}:=\Pr\left[\exists (i,j)\ \text{with}\ i\neq j: a_i=a_j\right].
	\] To calculate this probability, let $P'\of{n}:=1-P\of{n}$ then \begin{align*}
	P'\of{n}&=1-\Pr\left[\exists (i,j)\ \text{with}\ i\neq j: a_i=a_j\right]\\
	&=\Pr\left[\forall(i,j)\ \text{with}\ i\neq j: a_i\neq a_j\right].
	\end{align*}
	That is, $P' (n)$ be the probability that all $n$ birthdays are unique.
	
	\newpage
	Assuming there are 365 possible birthdays, the probability that the first person has a unique birthday is:
	\begin{equation*}
	P'_1 = \frac{365}{365} = 1.
	\end{equation*}
	For the second person to have a unique birthday (different from the first person), there are 364 remaining possibilities:
	\begin{equation*}
	P'_2 = \frac{364}{365}.
	\end{equation*}
	For the third person to have a unique birthday (different from the previous two), there are 363 remaining possibilities:
	\begin{equation*}
	P'_3 = \frac{363}{365}.
	\end{equation*}
	Following this pattern, the probability that all $n$ birthdays are unique is:
	\begin{equation*}
	P'(n) = \frac{365}{365} \times \frac{364}{365} \times \cdots \times \frac{365 - (n - 1)}{365}.
	\end{equation*}
	Thus, the probability that at least two people share a birthday is:
	\begin{equation*}
	P(n) = 1 - P'(n)=1-\of{\frac{365}{365}}\of{\frac{364}{365}}\cdots\of{\frac{365-(n-1)}{365}}.
	\end{equation*}
	\vspace{8pt}
	\begin{tcolorbox}[colback=white,colframe=procolor,arc=5pt,title={\color{white}\bf Generalization of Birthday Problem}]
		\begin{proposition}
			Assume all birthday are equally likely, and generalize the problem a little: \textnormal{from $n$ possible birthdays, sample $k$ times with replacement}. \begin{align*}
			P(\textnormal{a shared birthday})&=1-P(\textnormal{no shared birthdays})\\
			&=1-P(\textnormal{all birthdays are unique})\\
			&=1-\of{\frac{n}{n}}\of{\frac{n-1}{n}}\cdots\of{\frac{n-(k-1)}{n}}\\
			&=1-1\cdot \prod_{i=1}^{k-1}\frac{n-i}{n}\\
			&=1-\prod_{i=1}^{k-1}\of{1-\frac{i}{n}}.
			\end{align*}
		\end{proposition}
	\end{tcolorbox}
	
	\iffalse
	\newpage
	\begin{remark}
		When $n=365$, the lowest $k$ for which the above exceeds $0.5$ is $k=23$: \begin{figure}[ht!]
			\centering
			%\includegraphics[width=0.95\linewidth,height=95mm]{birthday_problem.png}
		\end{figure}
		\begin{lstlisting}[style=sage, caption={Birthday Bound (Sage)},captionpos=t]
		import matplotlib.pyplot as plt
		
		# Define a function to compute the probability of two people sharing a birthday for a given group size
		def birthday_prob(n):
		return 1 - prod([(365-i)/365 for i in range(n)])
		
		# Create a list of group sizes from 2 to 50
		group_sizes = range(2, 51)
		
		# Compute the probabilities for each group size
		probabilities = [birthday_prob(n) for n in group_sizes]
		
		# Plot the probabilities as a function of group size
		plt.plot(group_sizes, probabilities)
		plt.xlabel("Group Size")
		plt.ylabel("Probability")
		plt.title("Probability of Two People Sharing a Birthday")
		
		# Add a horizontal line at the probability of 0.5
		plt.axhline(y=0.5, color='r', linestyle='-')
		
		plt.show()
		\end{lstlisting}
	\end{remark}
	\fi
	\newpage
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf Birthday Bound}]
		\begin{theorem}
			From the set $I:=\set{1,\cdots,n}$, sample $k$ times with replacement: \[
			a_1,a_2,\cdots,a_k\uniform\set{1,2,\cdots,n}
			\] where all element of $I$ are equally likely. Then \[
			P_{n,k}:=\Pr\left[\exists \of{i,j}\in I^2, i\neq j:a_i=a_j\right]\approx 1-e^{-\frac{k^2}{2n}}.
			\]
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		Note that \begin{align*}
		P_{n,k}=1-\Pr[a_i\neq a_j\ \text{for all distinct}\ i,j]=1-\prod_{i=1}^{k-1}\of{1-\frac{i}{n}}.
		\end{align*} Recall that Taylor series for exponential: \[
		e^x=1+x+\frac{1}{2!}x^2+\frac{1}{3!}x^3+\cdots=\sum_{k=0}^{\infty}\frac{x^k}{k!}.
		\] Note that $e^x\approx1+x$ for $x\in(-1,1)$:
		\begin{figure}[ht!]
			\centering
			%\includegraphics[scale=0.5]{approx_exp.png}
		\end{figure}\\
		Since $i\in[1,k-1]\subseteq[1,n)\Rightarrow-\frac{i}{n}\in\of{-1,1}\Rightarrow 1+\of{-\frac{i}{n}}\approx e^{-i/n}$, we have \begin{align*}
		P_{n,k}=
		1-\prod_{i=1}^{k-1}\of{1-\frac{i}{n}}
		&\approx 1-\prod_{i=1}^{k-1}e^{-\frac{i}{n}}\\
		&=1-e^{-1/n}\cdot e^{-2/n}\cdots e^{-(k-1)/n}\\
		&=1-e^{-\frac{1}{n}\of{1+2+\cdots+(k-1)}}\\
		&=1-e^{-\frac{1}{n}\cdot\frac{k\of{k-1}}{2}}\\
		&\approx 1-e^{-\frac{k^2}{2n}}.
		\end{align*}
	\end{proof}
	
	\begin{remark}
		Find minimum value of $k$ such that $P_{n,k}\geq 1/2$. \begin{align*}
		P_{n,k}=1-e^{-\frac{k^2}{2n}}\geq\frac{1}{2}&\implies e^{-k^2/2n}\leq\frac{1}{2}\\
		&\implies-\frac{k^2}{2n}\leq\ln\frac{1}{2}\\
		&\implies (2\ln2)n\leq k^2\\
		&\implies \ceil*{\sqrt{\of{2\ln 2}n}}\leq k.
		\end{align*} 
		Thus, $k\geq c\sqrt{n}$, where $c$ is a constant. That is, $O(\sqrt{n})$.
	\end{remark}
	
	\iffalse
	\begin{remark}
		Find the upper bound of $P_{n,k}$. \begin{align*}
		P_{n,k}
		&=\Pr\left[(a_1=a_2)\lor\cdots\lor(a_1=a_k)\lor(a_2=a_3)\lor\cdots\lor(a_{k-1}=a_k)\right]\\
		&\leq\sum_{1\leq i< j\leq k}\Pr\left[a_i=a_j\right]\\
		&=\binom{k}{2}\frac{1}{n}\\
		&\leq\frac{k^2}{2n}.
		\end{align*} Thus, the upper bound of $P_{n,k}$ is less than 1/2 when $k=\floor*{\sqrt{n}}$.
	\end{remark}
	\fi
	
	\section{Set Intersection Bound}
	
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf Set Intersection Bound}]
		\begin{theorem}
			Consider a set $S$ with $\abs{S}=n$. Let \[
			a_1,a_2,\cdots, a_k\uniform S,\quad b_1,b_2,\cdots, b_k\uniform S
			\] for $k<n$. For two multi-set $A=[a_1,a_2,\cdots,a_k]$ and $B=[b_1,b_2,\cdots, b_k]$, we have \[
			\Pr[A\cap B\neq\emptyset]=1-e^{-\frac{k^2}{n}}
			\]
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		For all $i,j\in\set{1,\cdots, k}$, we have \[
		\Pr[a_i=b_j]=\frac{1}{n}\implies\Pr[a_i\neq b_j]=1-\frac{1}{n}.
		\] Thus \begin{align*}
		\Pr[A\cap B\neq\emptyset]&=1-\prod_{i=1}^k\prod_{j=1}^k\Pr[a_i\neq b_j]\\
		&=1-\prod_{i=1}^k\prod_{j=1}^k\of{1-\frac{1}{n}}\\
		&=1-\of{1-\frac{1}{n}}^{k^2}\\
		&\approx 1-\of{e^{-\frac{1}{n}}}^{k^2}\\
		&=1-e^{-\frac{k^2}{n}}.
		\end{align*}
	\end{proof}
	
	\begin{remark}
		Find minimum value of $k$ such that $P_{n,k}\geq 1/2$. \begin{align*}
		P_{n,k}=1-e^{-\frac{k^2}{n}}\geq\frac{1}{2}&\implies e^{-k^2/n}\leq\frac{1}{2}\\
		&\implies-\frac{k^2}{n}\leq\ln\frac{1}{2}\\
		&\implies (\ln2)n\leq k^2\\
		&\implies \ceil*{\sqrt{\of{\ln 2}n}}\leq k.
		\end{align*} 
		Thus, $k\geq c\sqrt{n}$, where $c$ is a constant. That is, $O(\sqrt{n})$.
	\end{remark}
	
	\newpage
	\section{Finding Collision of a (One-way) Function}
	
	
	
	Finding a collision for a one-way function is a computationally hard problem. We can define a one-way function as:
	\[
	f : \set{0,1}^*\to \set{0,1}^n
	\] By the pigeon-hole principle, there are \hl{collision}. A collision in a one-way function is a pair of inputs:
	\[
	x_1,x_2\in\set{0,1}^*\ \text{such that}\ f\of{x_1}=f\of{x_2}\ \text{but}\ x_1\neq x_2.
	\]
	
	One common method used to find a collision is the \textit{birthday attack}, which is based on the birthday paradox. The birthday paradox states that in a group of 23 people, there is a 50\% chance that two people share the same birthday, assuming uniform distribution of birthdays over 365 days.
	
	\begin{algorithm}[H]
		\caption{{Birthday Attack} to Find a Collision in a One-way Function}
		\KwData{One-way function $f$.}
		\KwResult{Collision pair $(x_1,x_2)$.}
		\vspace{4pt}
		\vspace{4pt}
		\begin{minipage}{.45\textwidth}
			Initialize an empty set $S=\varnothing$\;
			\vspace{4pt}
			\While{\texttt{True}}{
				$x\uniform\set{0,1}^*$\;
				$y\gets f\of{x}$\;
				\eIf{$y\in S$}{
					\Return $(x_1,x_2)$ s.t. $f\of{x_1}=f\of{x_2}=y$\;
				}{
					$S\gets S\cup\set{y}$\;
				}
			}
			\vspace{15pt}
		\end{minipage}\hfil
		\begin{minipage}{.45\textwidth}
			Initialize an empty dictionary $D$\;
			\vspace{4pt}
			\While{\texttt{True}}{
				$x\uniform\set{0,1}^*$\;
				$y\gets f\of{x}$\;
				\eIf{$y$ is a key in $D$}{
					$x_1\gets x$\;
					$x_2\gets D[y]$\;
					\Return $(x_1,x_2)$\;
				}{
					$D\gets D\cup\set{(y,x)}$\;
				}
			}
		\end{minipage}
		\vspace{4pt}
	\end{algorithm}
	The dictionary stores $D$ key-value pairs where the key is the output value $y$ and the value is the corresponding input value 
	$x$. This way, we can keep track of the input values corresponding to the computed output values.
	
	\newpage
	\subsection{Native Approach}
	
	From $2^n$ possible outputs of $f$, sample $k$ times with replacement: \[
	P\of{\textnormal{no collision for $k$ inputs}}=\prod_{i=1}^{k-1}\of{1-\frac{i}{2^n}}.
	\]
	Then \begin{align*}
	\prod_{i=1}^{k-1}\of{1-\frac{i}{2^n}}\approx e^{-\frac{k^2}{2\cdot 2^n}}\geq\frac{1}{2}
	&\implies (2\ln2)2^n\leq k^2\\
	&\implies \sqrt{2\ln2}\sqrt{2^n}\leq k.
	\end{align*}
	For $N=O(\sqrt{2^n})$, we generate the set of input/output pairs \[
	S=\set{\of{x_i,f\of{x_i}}}_{i=1}^N.
	\] By the birthday bound, \[
	\Pr[\exists(x_i,f(x_i)),(x_j,f(x_j))\in S:f(x_i)=f(x_j)]\approx\frac{1}{2}.
	\]
	\vspace{8pt}
	\begin{remark}[Memory Space]
		To store $k$ inputs, each of which is represented by $n$ bits, we need $k \times n$ bits. If we consider that the probability of a collision is greater than 50\% when $k > \sqrt{2^n}$, the memory space required to store these inputs is approximately: \[
		\sqrt{2^n}\times n.
		\] Thus the memory space needed to store $n$-bit i/o is approximately $\sqrt{2^n}\times n\times 2$.
	\end{remark}
	\vspace{8pt}
	\begin{example}
		Consider $160$-bit output function. Then 
		\begin{align*}
		\text{Memory space} &= \sqrt{2^n} \times n \times 2 \\
		&= 2^{80} \times 160 \times 2 \\
		&= 2^{80} \times 2^5\times 5 \times 2 \\
		&= 10\times 2^{85}\\
		&= 10\times 2^{82} \times 2^3 (= 10\times 2^{82}\ \text{bytes})\\
		&= 10 \times 2^{42}\ \text{TB}.
		\end{align*}
	\end{example}
	
	\newpage
	\subsection{Small-Space Attack using Floyd's Cycle-Finding}
	Floyd's cycle-finding algorithm is a method to detect cycles in a sequence of values, using a small amount of memory. It is particularly useful for finding cycles in functions, like hash functions or pseudorandom number generators. In the context of a small-space attack, an adversary tries to find a collision (two inputs producing the same output) with limited memory resources.
	\vspace{8pt}\\
	\begin{algorithm}[H]
		\caption{Small-Space Attack; Floyd's Cycle-Finding Algorithm}
		\KwData{One-way function $\hash:\set{0,1}^*\to\set{0,1}^n$.}
		\KwResult{Collision pair $(x,x')$ such that $x\neq x'$ but $\hash\of{x}=\hash\of{x'}$.}
		\BlankLine
		\Comment{Step1: We discover $k$ such that $x_k=x_{2k}$}
		\vspace{4pt}
		$x_0\uniform\set{0,1}^{n+1}$ \tcp*{$x_0\notin\img\hash$ is the start node}
		\vspace{4pt}
		$\of{x,x'}\gets\of{x_0,x_0}$\;
		\BlankLine
		\While{\texttt{True}}{
			$\of{x,x'}\gets\of{H\of{x},\of{H\circ H}\of{x}}$\;
			\If{$x=x'$}{
				\Break\;
			}
		}\BlankLine
		\Comment{Step2: Using $(x_0, x_k)$ obtained in Step1, we find the collision pair}
		\BlankLine$\of{x,x'}\gets\of{x_0,x'}$\;
		\BlankLine
		\While{\texttt{True}}{
			\eIf{$\hash\of{x}=\hash\of{x'}$}{
				\Return $\of{x,x'}$
			}{
				$\of{x,x'}\gets\of{\hash\of{x},\hash\of{x'}}$\;
			}
		}
	\end{algorithm}
	\vspace{8pt}
	\begin{center}
		\begin{tikzpicture}[
		node distance = .2cm and .3cm,
		block/.style = {rectangle split, rectangle split parts=2, draw, anchor=center},
		arr/.style = {-Stealth, line width=0.8pt}
		]
		\node[block] (A) {0\nodepart{two}$x_0$};
		\node[block, right=of A] (B) {1\nodepart{two}$f(x_0)$};
		\node[block, right=of B] (C) {2\nodepart{two}$(f\circ f)(x_0)=:f^2(x_0)$};
		\node[block, right=1.5cm of C] (D) {$I$\nodepart{two}$f^I(x_0)$};
		\node[block, right=of D] (E) {$I + 1$\nodepart{two}$f^{I + 1}(x_0)$};
		\node[block, right=of E] (F) {$\cdots$\nodepart{two}$\cdots$};
		\node[block, right=of F] (G) {$J$\nodepart{two}$f^{J}(x_0)$};
		\node[draw=none, below=.7cm of C] (dots) {$\cdots$};
		
		\draw[arr] (A) -- (B);
		\draw[arr] (B) -- (C);
		\draw[arr] (C) -- (dots);
		\draw[arr] (dots) -- (D);
		\draw[arr] (D) -- (E);
		\draw[arr] (E) -- (F);
		\draw[arr] (F) -- (G);
		\draw[arr] (G) edge[bend right=45] (D);
		\end{tikzpicture}
	\end{center}
	We define a sequence $\set{x_i}_{i>0}$ as follows: \[
	x_{i}:=f(x_{i-1}).
	\] Here, $x_0\in\set{x\mid f(x)\neq x}$. Note that a sequence $\set{x_i}$ has a collision pair because $\abs{X}<\infty$ (feat. pigeon-hole principle).
	
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf }]
		\begin{theorem}
			Define a sequence $\set{x_i}_{i>0}$ as follows: \[
			x_{i}:=f\of{x_{i-1}}
			\] with initial node $x_0\notin\img\of{f}$. Then $\exists k>I$ such that $x_k=x_{2k}$:
			\begin{center}
				\begin{tikzpicture}[
				node distance = .2cm and .4cm,
				block/.style = {rectangle split, rectangle split parts=2, draw, anchor=center},
				arr/.style = {-Stealth, line width=0.8pt}
				]
				\node[block] (A) {0\nodepart{two}$x_0$};
				\node[block, right=2.5cm of A] (B) {$I$\nodepart{two}$f^I(x_0)$};
				\node[block, right=of B] (C) {$I + 1$\nodepart{two}$f^{I + 1}(x_0)$};
				\node[block, right=of C] (D) {$\cdots$\nodepart{two}$\cdots$};
				\node[block, right=of D] (E) {$k=2k$\nodepart{two}$f^{k}=f^{2k}$};
				\node[block, right=of E] (F) {$\cdots$\nodepart{two}$\cdots$};
				\node[block, right=of F] (G) {$J$\nodepart{two}$f^{J}(x_0)$};
				\node[draw=none, below=.7cm of B] (dots) {$\cdots$};
				
				\draw[arr] (A) -- (dots);
				\draw[arr] (dots) -- (B);
				\draw[arr] (B) -- (C);
				\draw[arr] (C) -- (D);
				\draw[arr] (D) -- (E);
				\draw[arr] (E) to[out=315, in=225, looseness=2, loop] (E);
				\draw[arr] (E) -- (F);
				\draw[arr] (F) -- (G);
				\draw[arr] (G) edge[bend right=45] (C);
				\end{tikzpicture}
			\end{center}
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		Let $(x_I, x_J)$ be a collision pair with $0\leq I< J\leq N\of{=O\of{\sqrt{2^n}}}$; that is, $x_I\neq x_J$ but $f(x_I)=f(x_J)$.
		For $J>I$, we have a circular sequence $\set{x_j}_{j>I}$:\[
		\quad x_J,x_{I+1},x_{I+2},\cdots, x_{I+(J-I)}(=x_J),\cdots
		\] with the period of $\lambda=J-I>0$. That is, \[
		x_j = x_{j+t\cdot\lambda}\quad\text{for some}\quad t\in\Z_{\geq 0}.
		\]
		Define a number \[
		k:=\min\set{t\lambda\in\mathbb{Z}_{>I}:t\in\mathbb{N}}>I.
		\] In other words, $k$ is the smallest multiple greater than $I$ of the period of $\lambda$. Clearly,
		$\lambda\mid k \implies \lambda\mid 2k$, that is, $2k$ is also multiple of the period of $\lambda$. Hence the equality $x_k=x_{2k}$ holds.
	\end{proof}
	\vspace{8pt}
	\begin{remark}
		We know that $\exists k>I$ such that $x_k=x_{2k}$. Since \begin{align*}
		x_k=f(x_{k-1}),\quad x_{2k}=f(x_{2k-1}),
		\end{align*} by the definition of $\set{x_i}_{i>0}$, then, we obtain $f(x_{k-1})=f(x_{2k-1})$. But $(x_{k-1},x_{2k-1})$ may not be a collision pair. \textcolor{blue}{Let $x_\alpha$ is the \underline{initial term} of a circular sequence $\set{x_j}_{j>I}$.} Since $k$ is a multiple of the period of $\lambda$ of $\set{x_j}_{j>I}$, Then, we see that \begin{align*}
		x_\alpha&=x_{\alpha+k}\quad\because\text{$k$ is the multiple of the period of $\lambda$}\\
		f(x_{\alpha-1})&=f(x_{\alpha+k-1})\quad\text{by the def. of $\set{x_i}_{i>0}$},\\
		\end{align*} and so $(x_{\alpha-1},x_{\alpha+k-1})$ is a clear collision pair.
	\end{remark}
	
	\iffalse
	\begin{lstlisting}[style=sage, caption={Small-Sapce Attack (Sage)},captionpos=t]
	N = 2^13 - 1 #12-bit
	n = floor(sqrt(N))
	print("N = {}\nn = floor(sqrt N) = {}\n".format(N,n))
	
	def f(x):
	return (x^2 + 1) % N
	
	# Step 1: Discover k such that x_k = x_{2k}
	x0 = ZZ.random_element(N, 2*N) #x0 is the start node
	x1, x2 = x0, x0
	k = 0
	while True :
	k = k + 1
	x1, x2 = f(x1), f(f(x2))
	if x1 == x2 :
	print ("k = {}, 2k = {}".format(k, 2*k))
	break
	
	# Step 2: Find the collision pair
	x1 , x2 = x0, x2
	for i in [0..k]:
	if f(x1) == f(x2):
	print("Collision: ({}-th elt = {}, {}-th elt = {}) ".format(i, x1, k+i, x2))
	break
	else :
	x1, x2 = f(x1), f(x2)
	
	L = [(0, x0)]
	for j in [1..2*k]:
	L = L + [(j, f(L[j-1][1]))]
	
	# list_plot(L)
	
	for pair in L:
	print(pair)
	\end{lstlisting}
	\fi	
	
	\newpage
	\chapter{Discrete Logarithm Problem}
	In cryptography, the discrete logarithm problem (DLP) is the problem of computing $x$ given $g$, $h$, and $n$, where \begin{enumerate}[(i)]
		\item $G=\langle g\rangle$ with $\abs{G}=n$;
		\item $h=g^x\in G$.
	\end{enumerate} In other words,  \begin{center}
		``Given $h\in\langle g\rangle$, find $x\in[0,n)$ such that $g^x=h$''.
	\end{center}
	
	\section{DLP Solutions}
	\begin{center}
		\begin{tabular}{c|c|c|c}
			\toprule[1.2pt]
			Order & Algorithm & Complexity & Cyclic Group \\ \hline\hline
			$n$ & Exhaustive Search & $O(n)$ & General \\ \hline
			$n$ & Baby-Step/Giant-Step & $O(\sqrt{n})$ & General \\ \hline
			$p$ (prime) & Pollard-$\rho$ & $O(\sqrt{p})$ & General \\ \bottomrule[1.2pt]
		\end{tabular}
	\end{center}
	
	\section{Exhaustive Search}
	\begin{itemize}
		\item Time Complexity: $O(n)$
		\item Memory Complexity: $O(1)$
	\end{itemize}
	\begin{algorithm}[H]
		\caption{DLP Solution: Brute Force Search}
		\KwData{Cyclic group $G=\langle g\rangle$ with order $n$, and $h\in G$.}
		\KwResult{$x\in\set{0,1,\cdots, n-1}$ such that $g^x=h$.}
		\BlankLine
		$t\gets 1$\;
		\vspace{4pt}
		\For{$j\gets 0$ \KwTo $n-1$}{
			\eIf{$t=h$}{
				\Return j\;
			}{
				$t\gets tg$\;
			}
		}
	\end{algorithm}
	
	
	\newpage
	\section{Shanks' Algorithm: Baby-Step/Giant-Step (1971)}
	
	\begin{algorithm}[H]
		\KwData{A group G of order $n$ with generator $g$, and an element $h$ in $G$.}
		\KwResult{The discrete logarithm $x\in\Z_n$ such that $g^x = h$.}
		$m \leftarrow \lfloor\sqrt{n}\rfloor+1$ \tcp*{$m>\sqrt{n}$}
		$SB\gets\set{(i,g^i):i=0,1,\cdots, m-1}$ \tcp*{Baby-step}
		$SB\gets\set{\of{j, h(g^{-m})^j}:i=0,1,\cdots, m-1}$ \tcp*{Giant-step}
		Find $i,j$ such that $g^{i}=h\of{g^{-m}}^j$\;
		\Return $x\gets mj+i$\;
		\caption{Shanks' Baby-step/Giant-step Algorithm}
	\end{algorithm}
	\vspace{8pt}
	Consider cyclic group $G=\langle g\rangle$ of order $n$. We want to find $k$ such that $g^k=h$ for some $h\in G$. Clearly, $k\in\set{0,1,\cdots, n-1}=\Z_n$. Define a number $m:=\floor*{\sqrt{n}}+1$. By division theorem, $\exists!q,r\in\Z_{\geq 0}$ such that \[
	k=mq+r,\quad 0\leq r<m.
	\] Note that \[
	\sqrt{n}<m=\frac{k-r}{q}\leq\frac{k}{q}<\frac{n}{q}\implies q<\frac{n}{\sqrt{n}}=\sqrt{n}\implies 0\leq q<\sqrt{n}<m.	
	\] That is, $r,q\in\Z_m$. Then \[
	h=g^k=g^{mq+r}\implies g^r=h\of{g^{-m}}^q.
	\] Define two sets  \begin{align*}
	BS &:= \set{g^i:i=0,1,\cdots, m-1},\\
	GS &:= \set{h\of{g^{-m}}^j:j=0,1,\cdots, m-1}.
	\end{align*} Clearly $BS\cap GS\neq\emptyset$. Thus we can find $i,j\in\Z_m$ such that $g^i=h\of{g^{-m}}^j$. Hence we obtain  the discrete logarithm \[
	k=mj+i.
	\]
	
	\newpage
	\section{Pollard $\rho$ Method for DLP (1978)}
	
	The Pollard's rho method is based on the idea of finding a collision in a sequence of group elements and their corresponding exponents.
	\vspace{8pt}\\
	\begin{algorithm}[H]
		\caption{Pollard's $\rho$ Method for DLP}
		\KwData{Cyclic group $G=\langle g\rangle=\dot{\bigcup}_{i=1}^3G_i$ with prime order $p$, and $h\in G$.}
		\KwResult{The discrete logarithm $x\in\Z_p$ such that $g^x=h$ or \texttt{Failure}}
		\BlankLine
		\Comment{$\operatorname{\textnormal{Proj}}_0,\operatorname{\textnormal{Proj}}_1,\operatorname{\textnormal{Proj}}_2:G^3\to G:\operatorname{\textnormal{Proj}}_j\of{x_0,x_1,x_2}=x_j$,\quad $j=0,1,2$.}
		\BlankLine
		$x_0\gets \of{g^0h^0, 0, 0}$ \tcp*{$x_0$ is the start node}
		$\of{X,X'}\gets\of{x_0,x_0}$\;
		\BlankLine
		\While{\texttt{True}}{
			$\of{X,X'}\gets\of{f\of{X},f^2\of{X'}}$ \tcp*{$f\of{x_j,a_j,b_j}=\of{x_{j+1},a_{j+1},b_{j+1}}$}
			\If{$\operatorname{\textnormal{Proj}}_0\of{X}=\operatorname{\textnormal{Proj}}_0\of{X'}$}{
				\Break\tcp*{$x_j=x_{2j}$}
			}
		}
		\BlankLine
		\Comment{$b_{2j}-b_j\neq0$}
		\BlankLine
		\eIf{$\operatorname{\textnormal{Proj}}_2\of{X}\neq\operatorname{\textnormal{Proj}}_2\of{X'}$}{
			$t_1\gets\of{\operatorname{\textnormal{Proj}}_1(X)-\operatorname{\textnormal{Proj}}_1(X)}$\;
			$t_2\gets\of{\operatorname{\textnormal{Proj}}_2(X')-\operatorname{\textnormal{Proj}}_2(X')}^{-1}$\tcp*{EEA}
			\Return $t_1t_2\mod p$
		}{
			\Return \texttt{Failure}\;
		}
	\end{algorithm}
	\vspace{8pt}
	Consider a group $G$ of \textit{prime} order $p$ with generator $g$. We want to find $k$ such that $g^k=h\in G=\langle g\rangle$.
	\begin{itemize}
		\item[] (Step I) \[
		G=G_1\dot{\cup}G_2\dot{\cup}G_3,\quad \abs{G_1}\approx\abs{G_2}\approx\abs{G_3}.
		\]
		\vspace{4pt}
		\item[] (Step II) Define a sequence $\set{x_j,a_j,b_j}_{j=0}^\infty=\set{g^{a_j}h^{b_j},a_j,b_j}_{j=0}^\infty$ as follows: \[
		\of{x_j,a_j,b_j}:=\begin{cases}
		\of{g^0h^0, 0, 0} &: j=0,\\
		\of{x_{j-1}h, a_{j-1}, b_{j-1}+1\mod p}&: j\geq 1\ \text{and}\ x_{j-1}\in G_1,\\
		\of{x_{j-1}^2, 2a_{j-1}\mod p, 2b_{j-1}\mod p}&: j\geq 1\ \text{and}\ x_{j-1}\in G_2,\\
		\of{gx_{j-1}, a_{j-1}+1\mod p, b_{j-1}}&: j\geq 1\ \text{and}\ x_{j-1}\in G_3.
		\end{cases}
		\]
		\vspace{4pt}
		\newpage
		\item[] (Step III) Using Floyd's cycle-finding, we find $\of{x_j,a_j,b_j}$ and $\of{x_2j,a_{2j},b_{2j}}$ such that $x_j=x_{2j}$:
		\begin{center}
			\begin{tikzpicture}[
			node distance = .2cm and .3cm,
			block/.style = {rectangle split, rectangle split parts=2, draw, anchor=center},
			arr/.style = {-Stealth, line width=0.8pt}
			]
			\node[block] (A) {$0$\nodepart{two}$g^{a_0}h^{b_0}$};
			\node[block, right=0.7cm of A] (B) {$I$\nodepart{two}$g^{a_I}h^{b_I}$};
			\node[block, right=of B] (C) {$I+1$\nodepart{two}$g^{a_{I+1}}h^{b_{I+1}}$};
			\node[block, right=of C] (D) {$\cdots$\nodepart{two}$\cdots$};
			\node[block, right=of D] (E) {$k=2k$\nodepart{two}$g^{a_{k}}h^{b_{k}}=g^{a_{2k}}h^{b_{2k}}$};
			\node[block, right=of E] (F) {$\cdots$\nodepart{two}$\cdots$};
			\node[block, right=of F] (G) {$J$\nodepart{two}$g^{a_{J}}h^{b_{J}}$};
			\node[draw=none, below=.7cm of B] (dots) {$\cdots$};
			
			\draw[arr] (A) -- (dots);
			\draw[arr] (dots) -- (B);
			\draw[arr] (B) -- (C);
			\draw[arr] (C) -- (D);
			\draw[arr] (D) -- (E);
			\draw[arr] (E) to[out=315, in=225, looseness=2, loop] (E);
			\draw[arr] (E) -- (F);
			\draw[arr] (F) -- (G);
			\draw[arr] (G) edge[bend right=45] (C);
			\end{tikzpicture}
		\end{center}
		\vspace{4pt}
		\item[] (Step IV) Find a collision pair!
		\begin{align*}
		g^{a_j}h^{b_j}=g^{a_{2j}}h^{b_{2j}} &\implies g^{a_j-a_{2j}}=h^{b_{2j}-b_j}=(g^{x})^{b_{2j}-b_j}\\
		&\implies a_j-a_{2j}\equiv x\of{b_{2j}-b_{j}}\pmod{p}\\
		&\implies x= \of{a_j-a_{2j}}\of{b_{2j}-b_{j}}^{-1}\mod{p}\quad\because\text{$p$ is a prime}.
		\end{align*}
	\end{itemize}
	
	\newpage
	\chapter{Algorithms}
	\section{Exponentiation}
	In this chapter, we introduce three algorithms to compute the exponentiation $x^n=\underbrace{x\times\cdots\times x}_n$ (or the constant multiple $nx=\underbrace{x+\cdots+x}_n$) for an $l$-bit positive integer $n=\sum_{j=0}^{l-1}n_j2^j$ with $n_j\in\set{0,1}$ and $n_{l-1}=1$\footnote{MSB:Most Significant Bit}.
	\begin{center}
		\begin{tikzpicture}
		% Parameters
		\def\l{6} % Length of the strip (number of bits)
		
		% Draw rectangles for bits and labels
		\foreach \j in {0,...,\l} {
			\draw (\j,0) rectangle (\j+1,1);
		}
		
		% Label the first two bits
		\node at (0.5,0.5) {$n_{l-1}$};
		\node at (1.5,0.5) {$n_{l-2}$};
		
		% Label the last two bits
		\node at (5.5,0.5) {$n_1$};
		\node at (6.5,0.5) {$n_0$};
		
		% Fill in the middle with \cdots
		\node at (2.5,0.5) {$\cdots$};
		\node at (3.5,0.5) {$\cdots$};
		\node at (4.5,0.5) {$\cdots$};
		
		% Label the exponent part
		\node[below] at (0.5,0) {$2^{l-1}$};
		\node[below] at (1.5,0) {$2^{l-2}$};
		\node[below] at (2.5,-.25) {$\cdots$};
		\node[below] at (3.5,-.25) {$\cdots$};
		\node[below] at (4.5,-.25) {$\cdots$};
		\node[below] at (5.5,0) {$2^{1}$};
		\node[below] at (6.5,0) {$2^{0}$};
		
		% Draw arrow and label n
		\draw[->,thick] (\l+1.5,0.5) -- (\l+2.5,0.5);
		\node[right] at (\l+2.5,0.5) {$n = \sum_{j=0}^{l-1} n_j 2^j$};
		\end{tikzpicture}
	\end{center}
	\begin{enumerate}[(1)]
		\item Left-to-Right Binary Method
		\item Right-to-Left Binary Method
		\item Multiply-and-Square Method (Montgomery Ladder)
	\end{enumerate}
	
	\begin{note}
		The operation $x^n$ is used in algorithms such as \begin{enumerate}[(i)]
			\item Diffie-Hellman (DH),
			\item Digital Signature Algorithm (DSA),
			\item and RSA,
		\end{enumerate} while the operation $nx$ is used in \begin{enumerate}[(i)]
			\item Elliptic Curve Diffie-Hellman (ECDH)
			\item and Elliptic Curve Digital Signature Algorithm (ECDSA).
		\end{enumerate}
	\end{note}
	
	\subsection{Left-to-Right Binary Method}
	
	\begin{algorithm}[H]
		\caption{Exponentiation: Left-to-Right Binary Method}
		\vspace{8pt}
		\begin{multicols}{2}
			\KwData{$x$ and $n=\sum_{j=0}^{l-1}n_j2^j$}
			\KwResult{$x^n$}
			\vspace{8pt}
			$t\to 1$\;
			\For{$i\gets l-1$ \Downto $0$}{
				$t\gets t^2$ \tcp*{Squaring}
				$t\gets tx^{n_i}$ \tcp*{Fixed multiplication}
			}
			\Return $t$\;
			\vspace{8pt}
			\columnbreak % Move to the next column
			\setcounter{AlgoLine}{0}  % Reset line numbering
			\KwData{$x$ and $n=\sum_{j=0}^{l-1}n_j2^j$}
			\KwResult{$nx$}
			\vspace{8pt}
			$t\to 0$\;
			\For{$i\gets l-1$ \Downto $0$}{
				$t\gets 2t$ \tcp*{Doubling}
				$t\gets t+{n_i}x$ \tcp*{Fixed addition}
			}
			\Return $t$\;
			\vspace{8pt}
		\end{multicols}
		\vspace{8pt}
	\end{algorithm}
	\vspace{4pt}
	\begin{algorithm}[H]
		\caption{\textcolor{red}{\bf Modular} Exponentiation: Left-to-Right Binary Method}
		\vspace{8pt}
		\begin{multicols}{2}
			\KwData{$x$ and $n=\sum_{j=0}^{l-1}n_j2^j$}
			\KwResult{$x^n$ \textcolor{red}{over $\F_p^*$}}
			\vspace{8pt}
			$t\to 1$ \;
			\For{$i\gets l-1$ \Downto $0$}{
				$t\gets t^2$ $\textcolor{red}{\mod p}$ \;
				$t\gets tx^{n_i}$ $\textcolor{red}{\mod p}$ \;
			}
			\Return $t$ \;
			\vspace{8pt}
			\columnbreak % Move to the next column
			\setcounter{AlgoLine}{0}  % Reset line numbering
			\KwData{$x$ and $n=\sum_{j=0}^{l-1}n_j2^j$}
			\KwResult{$nx$ \textcolor{red}{over $\Z_p$}}
			\vspace{8pt}
			$t\to 0$ \;
			\For{$i\gets l-1$ \Downto $0$}{
				$t\gets 2t$ $\textcolor{red}{\mod p}$ \;
				$t\gets \of{t+{n_i}x}$ $\textcolor{red}{\mod p}$ \;
			}
			\Return $t$ \;
			\vspace{8pt}
		\end{multicols}
		\vspace{8pt}
	\end{algorithm}
	\vspace{8pt}
	
	\textbf{Left-to-Right Binary Method} utilizes the following equation: \begin{align*}
	(n)_l=n_{l-1}\parallel n_{l-2}\parallel\cdots\parallel n_1\parallel n_0&=\sum_{j=0}^{l-1}n_j2^j\\
	&=n_{l-1}2^{l-1}+n_{l-2}2^{l-2}+\cdots+n_22^2+n_12+n_0\\
	&=2\of{n_{l-1}2^{l-2}+n_{l-2}2^{l-3}+\cdots+n_22+n_1}+n_0\\
	&=2\of{2\of{n_{l-1}2^{l-3}+n_{l-2}2^{l-4}+\cdots+n_2}+n_1}+n_0\\
	&=2\of{\cdots 2\of{2\of{2(0)+n_{l-1}}+n_{l-2}}\cdots}+n_0.
	\end{align*}
	Then \begin{align*}
	nx&=\of{\sum_{j=0}^{l-1}n_j2^j}x=2\of{\sum_{j=1}^{l-2}n_{j+1}2^j}x+n_0x,\\ x^n&=x^{\sum_{j=0}^{l-1}n_j2^j}=x^{2\sum_{j=1}^{l-2}n_j2^j+n_0}=\of{x^{\sum_{j=1}^{l-2}n_j2^j}}^2\times x^{n_0}.
	\end{align*}
	\begin{proof}[Correctness of algorithm \textnormal{(Left-to-Right Binary Method)}]
		Let \begin{align*}
		m_l&:=0,\\
		m_{l-1}&:=n_{l-1},\\
		m_{l-2}&:=n_{l-2}+2n_{l-1},\quad\of{n_{l-1}\parallel n_{l-2}}\\
		m_{l-3}&:=n_{l-3}+2n_{l-2}+2^2n_{l-1},\quad\of{n_{l-1}\parallel n_{l-2}\parallel n_{l-3}}\\
		&\vdots\\
		m_{0}&:=n_0+2n_1+2^2n_2+\cdots+2^{l-1}n_{l-1},\quad\of{n_{l-1}\parallel n_{l-2}\parallel n_{l-3}\parallel\cdots\parallel n_0=n}.
		\end{align*} That is, the following recurrence relation is generated: \[
		m_j:=\begin{cases}
		0 &: j=l\\
		2m_{j+1}+n_j &: j=l-1,l-2,\dots, 1, 0.
		\end{cases}
		\] Since $m_0 = n$, we obtain $x^n$ or $nx$ through the following process: \begin{center}
			$x^{m_l}=x^0=1\to x^{m_{l-1}}\to x^{m_{l-2}}\to\cdots\to x^{m_1}\to x^{m_0}=x^n$,\\
			\vspace{8pt}$
			x^{m_j}\leftarrow x^{2m_{j+1}+n_j}=x^{2m_{j+1}}x^{n_j}=\mathcolorbox{-blue}{\of{x^{m_{j+1}}}^2x^{n_j}}=\begin{cases}
			\of{x^{m_{j+1}}}^2 &: n_j=0\\
			\of{x^{m_{j+1}}}^2x &: n_j=1.
			\end{cases}$
		\end{center}\vspace{4pt}\begin{center}
			${m_l}x=0\cdot x=0\to{m_{l-1}}x\to {m_{l-2}}x\to\cdots\to {m_1}x\to {m_0}x=nx$,\\
			\vspace{8pt}$
			{m_j}x\leftarrow \of{2m_{j+1}+n_j}x=\mathcolorbox{-blue}{2\of{m_{j+1}x}+n_jx}=\begin{cases}
			2\of{m_{j+1}x} &: n_j=0\\
			2\of{m_{j+1}x}+x &: n_j=1.
			\end{cases}$
		\end{center}
	\end{proof}
	\vspace{8pt}
	\begin{example}
		$x^6=x^{\texttt{0b110}}=\of{\of{\of{1}^2x}^2x}^2$ and $6x=(\texttt{0b110})x=2\of{2\of{2\of{0}+x}+x}$.
		\begin{center}
			\begin{tikzpicture}[mystyle/.style={draw, minimum width=2cm, minimum height=1cm, text centered}]
			% Matrix to show the exponent bits
			\matrix (bits) [matrix of nodes, nodes={mystyle}] {
				$b_2$ & $b_1$ & $b_0$ \\
				1     & 1     & 0    \\
			};
			
			% Matrix to show the steps for each bit
			\matrix (steps) [matrix of nodes, nodes={mystyle}, below=1.5cm of bits] {
				Square: $1^2$ & Square: $x^2$ & Square: $x^6$ \\
				Multiply: $x$ & Multiply: $x^3$ &  \\
			};
			
			% Draw arrows between the exponent bits and the corresponding steps
			\foreach \i in {1, 2, 3} {
				\draw[->] (bits-2-\i.south) -- (steps-1-\i.north);
			}
			\end{tikzpicture}
		\end{center}
	\end{example}
	
	\subsection{Right-to-Left Binary Method}
	
	\begin{algorithm}[H]
		\caption{Exponentiation: Right-to-Left Binary Method}
		\vspace{8pt}
		\begin{multicols}{2}
			\KwData{$x$ and $n=\sum_{j=0}^{l-1}n_j2^j$}
			\KwResult{$x^n$}
			\vspace{8pt}
			$t_0,t_1\to 1,x$\;
			\For{$i\gets 0$ \KwTo $l-1$}{
				$t_0\gets t_0t_1^{n_i}$ \tcp*{Multiplication}
				$t_1\gets t_1^2$ \tcp*{Squaring}
			}
			\Return $t_0$\;
			\vspace{8pt}
			\columnbreak % Move to the next column
			\setcounter{AlgoLine}{0}  % Reset line numbering
			\KwData{$x$ and $n=\sum_{j=0}^{l-1}n_j2^j$}
			\KwResult{$nx$}
			\vspace{8pt}
			$t_0,t_1\to 0,x$\;
			\For{$i\gets 0$ \KwTo $l-1$}{
				$t_0\gets t_0+{n_i}t_1$ \tcp*{Addition}
				$t_1\gets 2t_1$ \tcp*{Doubling}
			}
			\Return $t_0$\;
			\vspace{8pt}
		\end{multicols}
		\vspace{8pt}
	\end{algorithm}
	\vspace{4pt}
	\begin{algorithm}[H]
		\caption{\textcolor{red}{\bf Modular} Exponentiation: Right-to-Left Binary Method}
		\vspace{8pt}
		\begin{multicols}{2}
			\KwData{$x$ and $n=\sum_{j=0}^{l-1}n_j2^j$}
			\KwResult{$x^n$ \textcolor{red}{over $\F_p^*$}}
			\vspace{8pt}
			$t_0,t_1\to 1,x$\;
			\For{$i\gets 0$ \KwTo $l-1$}{
				$t_0\gets t_0t_1^{n_i}$ $\textcolor{red}{\mod p}$ \;
				$t_1\gets t_1^2$ $\textcolor{red}{\mod p}$ \;
			}
			\Return $t_0$ \;
			\vspace{8pt}
			\columnbreak % Move to the next column
			\setcounter{AlgoLine}{0}  % Reset line numbering
			\KwData{$x$ and $n=\sum_{j=0}^{l-1}n_j2^j$}
			\KwResult{$nx$ \textcolor{red}{over $\Z_p$}}
			\vspace{8pt}
			$t_0,t_1\to 0,x$\;
			\For{$i\gets 0$ \KwTo $l-1$}{
				$t_0\gets t_0+{n_i}t_1$ $\textcolor{red}{\mod p}$ \;
				$t_1\gets 2t_1$ $\textcolor{red}{\mod p}$ \;
			}
			\Return $t_0$ \;
			\vspace{8pt}
		\end{multicols}
		\vspace{8pt}
	\end{algorithm}
	\vspace{8pt}
	
	\textbf{Right-to-Left Binary Method} utilizes the following equation: \begin{align*}
	x^n=x^{\sum_{j=0}^{l-1}n_j2^j}=x^{n_02^0+n_12^1+n_22^2+\cdots+n_{l-1}2^{l-1}}&=\of{x^{2^0}}^{n_0}\times \of{x^{2^1}}^{n_1}\times \of{x^{2^2}}^{n_2}\times \cdots\\
	&=\of{x^{2^0}}^{n_0}\times \of{\of{x^{2^0}}^2}^{n_1}\times \of{\of{\of{x^{2^0}}^2}^2}^{n_2}\times \cdots
	\end{align*}
	Then \begin{align*}
	x^{2^0}\xrightarrow{\textnormal{squaring}}\of{x^{2^0}}^2\xrightarrow{\textnormal{squaring}}\of{\of{x^{2^0}}^2}^2\xrightarrow{\textnormal{squaring}}\cdots
	\end{align*}
	\begin{proof}[Correctness of algorithm \textnormal{(Right-to-Left Binary Method)}]
		Let \begin{flushright}
			\begin{align*}
			m_0&:= & 0,\\
			m_{1}&:= & n_{0},\\
			m_{2}&:= & 2n_{1}+n_{0}\\
			m_{3}&:= & 2^2n_2+2n_{1}+n_{0}\\
			&\vdots\\
			m_{l}&:= &2^{l-1}n_{l-1}+2^{l-2}n_{l-2}+\cdots+2^2n_2+2n_1+n_0 .
			\end{align*}
		\end{flushright} That is, the following recurrence relation is generated: \[
		m_j:=\begin{cases}
		0 &: j=l\\
		2m_{j+1}+n_j &: j=l-1,l-2,\dots, 1, 0.
		\end{cases}
		\] Since $m_0 = n$, we obtain $x^n$ or $nx$ through the following process: \begin{center}
			$x^{m_l}=x^0=1\to x^{m_{l-1}}\to x^{m_{l-2}}\to\cdots\to x^{m_1}\to x^{m_0}=x^n$,\\
			\vspace{8pt}$
			x^{m_j}\leftarrow x^{2m_{j+1}+n_j}=x^{2m_{j+1}}x^{n_j}=\mathcolorbox{-blue}{\of{x^{m_{j+1}}}^2x^{n_j}}=\begin{cases}
			\of{x^{m_{j+1}}}^2 &: n_j=0\\
			\of{x^{m_{j+1}}}^2x &: n_j=1.
			\end{cases}$
		\end{center}\vspace{4pt}\begin{center}
			${m_l}x=0\cdot x=0\to{m_{l-1}}x\to {m_{l-2}}x\to\cdots\to {m_1}x\to {m_0}x=nx$,\\
			\vspace{8pt}$
			{m_j}x\leftarrow \of{2m_{j+1}+n_j}x=\mathcolorbox{-blue}{2\of{m_{j+1}x}+n_jx}=\begin{cases}
			2\of{m_{j+1}x} &: n_j=0\\
			2\of{m_{j+1}x}+x &: n_j=1.
			\end{cases}$
		\end{center}
	\end{proof}
	
	\newpage
	\subsection{Multiply-and-Square Method (Montgomery Ladder)}
	
	\begin{algorithm}[H]
		\caption{Exponentiation: Multiply-and-Square Method (a.k.a. Montgomery Ladder)}
		\vspace{8pt}
		\begin{multicols}{2}
			\KwData{$x$ and $n=\sum_{j=0}^{l-1}n_j2^j$}
			\KwResult{$x^n$}
			\vspace{8pt}
			$t_0,t_1\to 1,x$\;
			\For{$i\gets l-1$ \Downto $0$}{
				$t_{1-n_i}\gets t_0t_1$\;
				$t_{n_i}\gets t_{n_i}^2$\;
			}
			\Return $t_0$\;
			\vspace{8pt}
			\columnbreak % Move to the next column
			\setcounter{AlgoLine}{0}  % Reset line numbering
			\KwData{$x$ and $n=\sum_{j=0}^{l-1}n_j2^j$}
			\KwResult{$nx$}
			\vspace{8pt}
			$t_0,t_1\to 0,x$\;
			\For{$i\gets l-1$ \Downto $0$}{
				$t_{1-n_i}\gets t_0+t_1$\;
				$t_{n_i}\gets 2t_{n_i}$\;
			}
			\Return $t_0$\;
			\vspace{8pt}
		\end{multicols}
		\vspace{8pt}
	\end{algorithm}
	\vspace{8pt}
	\begin{proof}[Correctness of algorithm \textnormal{(Multiply-and-Square Method (a.k.a. Montgomery Ladder))}]	
		For $l$-bit integer $n=\sum_{j=0}^{l-1}n_j2^j=n_{l-1}\parallel n_{l-2}\parallel\cdots\parallel n_{1}\parallel n_0$, the followings are defined: \begin{align*}
		L_j&:=\floor*{\frac{n}{2^j}}=\of{n\gg j}=n_{l-1}\parallel\cdots\parallel n_j,\\
		R_j&:=L_j+1
		\end{align*} for $j=0,1,\cdots, l$. Note that \begin{align*}
		\begin{cases}
		L_0=\floor*{\frac{n}{2^0}}=\floor*{n}=n\\
		R_0=L_0+1=n+1
		\end{cases},\quad
		\begin{cases}
		L_l=\floor*{\frac{n}{2^l}}=0\\
		R_l=L_l+1=1
		\end{cases}.
		\end{align*} Since \begin{align*}
		L_j=(n\gg j)=n_{l-1}\parallel\cdots\parallel n_{j+1}\parallel n_j&=\of{n_{l-1}\parallel\cdots\parallel n_{j+1}\parallel 0} +n_j\\
		&=\of{L_{j+1}\ll 1}+n_j\\
		&=2\of{L_{j+1}}+n_j,
		\end{align*} we obtain \begin{align*}
		L_j&=2L_{j+1}+n_j\\
		&=L_{j+1}+\of{R_{j+1}-1}+n_j\quad\because R_{j+1}=L_{j+1}+1\\
		&=2{R_{j+1}}+n_j-2\quad\because R_{j+1}=L_{j+1}+1.
		\end{align*} Then \begin{center}
			\begin{tabular}{l||c|c}
				\toprule[1.2pt]
				$L_j$ & $n_j=0$ & $n_j=1$\\
				\midrule
				$2L_{j+1}+n_j$ & \textcolor{red}{$2L_{j+1}$} & $2L_{j+1}+1$\\
				\hline
				$L_{j+1}+\of{R_{j+1}-1}+n_j$ & \textcolor{blue}{$L_{j+1}+R_{j+1}-1$} & \textcolor{blue}{$L_{j+1}+R_{j+1}$}\\
				\hline
				$2{R_{j+1}}+n_j-2$ & $2{R_{j+1}}-2$ & \textcolor{red}{$2{R_{j+1}}-1$}\\
				\bottomrule[1.2pt]
			\end{tabular}
		\end{center}
		From the aforementioned equation, the following recurrence relation is derived: \[
		\begin{cases}
		(L_l,R_l)=(L_l,L_l+1)\leftarrow (0,1),\\\\
		(L_j,R_j)=(L_j,L_j+1)\leftarrow\begin{cases}
		(\textcolor{red}{2L_{j+1}},\textcolor{blue}{L_{j+1}+R_{j+1}}) &: n_j=0\\
		(\textcolor{blue}{L_{j+1}+R_{j+1}},\textcolor{red}{2R_{j+1}}) &: n_j=1.
		\end{cases}
		\end{cases}
		\]
		Thus, \[
		(x^{L_l},x^{R_l})=(1,x)\xrightarrow{n_{l-1}}(x^{L_{l-1}},x^{R_{l-1}})\xrightarrow{n_{l-2}}\cdots\xrightarrow{n_{1}}(x^{L_1},x^{R_1})\xrightarrow{n_0}(x^{L_0}=x^n,x^{R_0}).
		\]
	\end{proof}
	\vspace{8pt}
	\begin{example}
		$x^5=x^{\texttt{0b101}}$ and $5x=(\texttt{0b101})x$. Note that $5=1\parallel 0\parallel 1$.
		\begin{center}
			\begin{tikzpicture}[mystyle/.style={draw, minimum width=1cm, minimum height=1cm, text centered}]
			% Matrix to show the exponent bits
			\matrix (bits) [matrix of nodes, nodes={mystyle}] {
				$n_2$ & $n_1$ & $n_0$ \\
				$1$   & $0$  & $1$   \\
			};
			
			% Matrix to show the steps for each bit
			\matrix (steps) [matrix of nodes, nodes={mystyle}, below=1.5cm of bits] {
				$x^{0+1}=x^1$ & $x^{1\cdot 2}=x^2$ & $x^{2+3}=\mathcolorbox{-blue}{x^5}$\\
				$x^{1\cdot 2}=x^2$ & $x^{1+2}=x^3$ & $x^{3\cdot 2}=x^6$\\
			};
			
			% Draw arrows between the exponent bits and the corresponding steps
			\foreach \i in {1, 2, 3} {
				\draw[->] (bits-2-\i.south) -- (steps-1-\i.north);
			}
			\end{tikzpicture}
		\end{center}
		\iffalse
		\begin{center}
			\begin{tikzpicture}[mystyle/.style={draw, minimum width=1cm, minimum height=1cm, text centered}]
			% Matrix to show the exponent bits
			\matrix (bits) [matrix of nodes, nodes={mystyle}] {
				$n_{l-1}$ & $n_{l-2}$ & $\cdots$ & $n_1$ & $n_0$ \\
				$1$   & $0$       & $\cdots$ & $0$   & $1$   \\
			};
			
			% Matrix to show the steps for each bit
			\matrix (steps) [matrix of nodes, nodes={mystyle}, below=1.5cm of bits] {
				$R_0 \leftarrow 2R_0$ & $R_0 \leftarrow R_0 + R_1$ & $\cdots$ & $R_0 \leftarrow 2R_0$ & $R_0 \leftarrow 2R_0$ \\
				$R_1 \leftarrow R_0 + R_1$ & $R_1 \leftarrow 2R_1$ & $\cdots$ & $R_1 \leftarrow R_0 + R_1$ & $R_1 \leftarrow R_0 + R_1$ \\
			};
			
			% Draw arrows between the exponent bits and the corresponding steps
			\foreach \i in {1, 2, 4, 5} {
				\draw[->] (bits-2-\i.south) -- (steps-1-\i.north);
			}
			
			% Draw dots for the middle steps
			\draw[->, dotted] (bits-2-3.south) -- (steps-1-3.north);
			\end{tikzpicture}
		\end{center}
		\fi
	\end{example}
	
	
	\newpage
	The Montgomery Ladder is an efficient algorithm for computing the scalar multiplication of a point $P$ on an elliptic curve by an integer $k$. The algorithm is particularly useful for side-channel attack resistant implementations because it performs a constant number of curve operations, regardless of the value of $k$.
	
	Given a point $P$ on an elliptic curve and a non-negative integer $k$, we want to compute $kP$. First, represent the integer $k$ in binary as:
	\[
	k = b_n 2^n + b_{n-1} 2^{n-1} + \cdots + b_1 2^1 + b_0 2^0,
	\]
	where $b_i \in \{0, 1\}$.
	
	Initialize two points $R_0 = \mathcal{O}$ (the point at infinity) and $R_1 = P$. Then, iterate through the bits of $k$ from the most significant bit (MSB) to the least significant bit (LSB). For each bit $b_i$, perform the following steps:
	
	\begin{enumerate}
		\item If $b_i = 0$, perform the following operations:
		\begin{enumerate}
			\item $R_0 \leftarrow R_0 + R_1$
			\item $R_1 \leftarrow 2R_1$
		\end{enumerate}
		\item If $b_i = 1$, perform the following operations:
		\begin{enumerate}
			\item $R_1 \leftarrow R_0 + R_1$
			\item $R_0 \leftarrow 2R_0$
		\end{enumerate}
	\end{enumerate}
	
	After iterating through all the bits, the point $R_0$ will contain the computed value of $kP$.
	
	The Montgomery Ladder achieves efficiency because it requires only $2n$ elliptic curve operations (additions and doublings) for an $n$-bit scalar $k$, and it maintains a constant number of operations regardless of the value of $k$. This characteristic is particularly useful in cryptographic applications, where side-channel attacks exploiting variations in execution time or power consumption can reveal information about the secret scalar.
	
	\begin{tikzpicture}[mystyle/.style={draw, minimum width=2cm, minimum height=1cm, text centered}]
	% Matrix to show the exponent bits
	\matrix (bits) [matrix of nodes, nodes={mystyle}] {
		$b_n$ & $b_{n-1}$ & $\cdots$ & $b_1$ & $b_0$ \\
		1     & 0         & $\cdots$ & 1     & 1     \\
	};
	
	% Matrix to show the steps for each bit
	\matrix (steps) [matrix of nodes, nodes={mystyle}, below=1.5cm of bits] {
		$R_0 \leftarrow 2R_0$ & $R_0 \leftarrow R_0 + R_1$ & $\cdots$ & $R_0 \leftarrow 2R_0$ & $R_0 \leftarrow 2R_0$ \\
		$R_1 \leftarrow R_0 + R_1$ & $R_1 \leftarrow 2R_1$ &          & $R_1 \leftarrow R_0 + R_1$ & $R_1 \leftarrow R_0 + R_1$ \\
	};
	
	% Draw arrows between the exponent bits and the corresponding steps
	\foreach \i in {1, 2, 5} {
		\draw[->] (bits-2-\i.south) -- (steps-1-\i.north);
	}
	
	% Draw dots for the middle steps
	\draw[->, dotted] (bits-2-2.south) -- (steps-1-3.north);
	\end{tikzpicture}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	
	
	\newpage
	\chapter{Classification}
	
	\section{Encryption}
	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf Symmetric Key Encryption}]
		\begin{enumerate}[(1)]
			\item Key Generation: $\GenKey:\N\to\mathcal{K}$; $k\gets\GenKey(1^n)$ for a security parameter $n$
			\item Encryption: $\Encrypt:\mathcal{K}\times\mathcal{P}\to\mathcal{C}$; $c\gets\Encrypt(k;p)$
			\item Decryption: $\Decrypt:\mathcal{K}\times\mathcal{C}\to\mathcal{P}$; $p\gets\Encrypt(k;c)$
		\end{enumerate}
	\end{tcolorbox}
	\vspace{8pt}
	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf Public Key Encryption}]
		\begin{enumerate}[(1)]
			\item Key Generation: $\GenKeyPair:\N\to\mathcal{K}_p\times\mathcal{K}_s$; \[
			pk,sk\gets\GenKeyPair(1^n)
			\] for a security parameter $n$
			\item Encryption: $\Encrypt:\mathcal{K}_p\times\mathcal{P}\to\mathcal{C}$;
			$$c\gets\Encrypt(pk;p)$$
			\item Decryption: $\Decrypt:\mathcal{K}_s\times\mathcal{C}\to\mathcal{P}$;
			$$p\gets\Encrypt(sk;c)$$
		\end{enumerate} We call $pk$ public key and $sk$ secret key (or private key).
	\end{tcolorbox}
	
	\newpage
	\section{Objective of Attack}
	\subsection{$\OW$: Onewayness}
	\begin{table}[h]
		\centering\begin{tabular}{ccc}
			\toprule[1.5pt]
			Challenger & $\xleftrightarrow[\textnormal{\textcolor{britishracinggreen}{symmetric} and \textcolor{blue}{public}}]{\OW\ \textnormal{security game}}$ & Adversary $\mathcal{A}$\\
			\midrule
			\textcolor{britishracinggreen}{$k\gets\GenKey(1^n)$}\\
			\textcolor{blue}{$pk, sk\gets\GenKeyPair(1^n)$}\\
			\midrule
			$p\uniform\mathcal{P}$ & \multirow{3}{*}{$\xrightarrow{c}$} \\
			\textcolor{britishracinggreen}{$c\gets\Encrypt(k;p)$}\\
			\textcolor{blue}{$c\gets\Encrypt(pk;p)$}\\
			\midrule
			if $p=p'$, then & \multirow{3}{*}{$\xleftarrow{p'}$} & $\A$ thinks $p'$ s.t.\\
			$\mathcal{A}$ wins, & & \textcolor{britishracinggreen}{$\Decrypt(k;c)=p'$}\\
			else $\mathcal{A}$ loses. & & \textcolor{blue}{$\Decrypt(sk;c)=p'$} \\
			\bottomrule[1.5pt]
		\end{tabular}
		\caption{$\OW$ security game.}
	\end{table}
	In the $\OW$ attack, the advantage of the adversary $\A$, denoted as $\Adv_{\Pi}^{\OW}(\A)$, is expressed as follows: \begin{align*}
	\Adv_{\Pi}^{\OW}(\A)&:=\textcolor{britishracinggreen}{\Pr\left[p\gets\A\of{\Encrypt(k;p)}\right]}\\
	&:=\textcolor{blue}{\Pr\left[p\gets\A\of{\Encrypt(pk;p)}\right]}
	\end{align*} where $p\uniform\mathcal{P}$, \[
	\textcolor{britishracinggreen}{k\gets\GenKey(1^n)}\quad\text{and}\quad\textcolor{blue}{pk,sk\gets\GenKeyPair(1^n)}.
	\]
	
	\newpage
	\subsection{$\IND$: Indistinguishability}
	\begin{table}[h]
		\centering\begin{tabular}{c||ccc}
			\toprule[1.5pt]
			Step & Challenger & $\xleftrightarrow[\textnormal{\textcolor{britishracinggreen}{symmetric} and \textcolor{blue}{public}}]{\IND\ \textnormal{security game}}$ & Adversary $\mathcal{A}$\\
			\midrule
			\multirow{5}{*}{Phase I}& \textcolor{britishracinggreen}{$k\gets\GenKey(1^n)$}\\
			& \textcolor{blue}{$pk, sk\gets\GenKeyPair(1^n)$}\\
			&\multirow{2}{*}{$b\uniform\set{0,1}$} & \multirow{2}{*}{$\xleftarrow{p_0,p_1}$} & $\A$ choose $p_0,p_1\in\mathcal{P}$ s.t. \\
			&& & $p_0\neq p_1$ and $\abs{p_0}=\abs{p_1}$\\
			\midrule
			\multirow{6}{*}{Phase II} &\textcolor{britishracinggreen}{$c\gets\Encrypt(k;p_b)$} & \multirow{2}{*}{$\xrightarrow{c}$} \\
			&\textcolor{blue}{$c\gets\Encrypt(pk;p_b)$}\\
			\\
			&if $b=b'$, then & \multirow{3}{*}{$\xleftarrow{b'\gets j}$} & $\A$ thinks $p_j$ s.t.\\
			&$\mathcal{A}$ wins, & & \textcolor{britishracinggreen}{$\Decrypt(k;c)=p_j$}\\
			&else $\mathcal{A}$ loses. & & \textcolor{blue}{$\Decrypt(sk;c)=p_j$} \\
			\bottomrule[1.5pt]
		\end{tabular}
		\caption{$\IND$ security game.}
	\end{table}	
	$\Adv_{\Pi}^{\IND}\of{\A}$ is expressed as follows: \begin{align*}
	\Adv_{\Pi}^{\IND}\of{\A}&:=
	\textcolor{britishracinggreen}{2\abs{b\gets\A\of{\Encrypt(k;p_b)}-\frac{1}{2}}}\\
	&:=\textcolor{blue}{2\abs{b\gets\A\of{\Encrypt(pk;p_b)}-\frac{1}{2}}}
	\end{align*} where $b\uniform\set{0,1}$, \[
	\textcolor{britishracinggreen}{k\gets\GenKey(1^n)}\quad\text{and}\quad\textcolor{blue}{pk,sk\gets\GenKeyPair(1^n)}.
	\]
	
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf }]
		\begin{theorem}
			$\IND$-secure $\implies$ $\mathsf{SEM}$-secure.
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		Note that the following game: \begin{table}[h]
			\centering\begin{tabular}{ccccc}
				\toprule[1.5pt]
				Challenger & $\xleftrightarrow[\textnormal{game}]{\IND}$ & Adversary $\mathcal{A}$ & $\xleftrightarrow[\textnormal{game}]{\mathsf{SEM}}$ & Adversary $\mathcal{B}$ \\
				\midrule
				\textcolor{britishracinggreen}{$k\gets\GenKey(1^n)$}\\
				\textcolor{blue}{$pk,sk\gets\GenKeyPair(1^n)$}\\
				& \multirow{4}{*}{$\xleftarrow{p_0,p_1}$} & $\A$ choose $p_0,p_1$\\
				&& such that\\
				&& $g(p_0)\neq g(p_1)$ \\
				&& and $\abs{p_0}=\abs{p_1}$\\
				$b\uniform\set{0,1}$\\
				\midrule
				\textcolor{britishracinggreen}{$c\gets\Encrypt(k;p_b)$} & \multirow{2}{*}{$\xrightarrow{c}$} & & \multirow{2}{*}{$\xrightarrow{c}$} & \textcolor{britishracinggreen}{$t\gets g\of{\Decrypt(k;c)}$} \\
				\textcolor{blue}{$c\gets\Encrypt(pk;p_b)$} & & & & \textcolor{blue}{$t\gets g\of{\Decrypt(sk;c)}$}\\
				\midrule
				if $b=b'$, then & \multirow{3}{*}{$\xleftarrow{b'}$} & if $g(p_0)=t$, then, &\multirow{3}{*}{$\xleftarrow{\hat{t}}$} & \\
				$\mathcal{A}$ wins, & & $b'\gets 0$, & & \\
				else $\mathcal{A}$ loses. & & else $b'\gets 1$ & & \\
				\bottomrule[1.5pt]
			\end{tabular}
			\caption{$\mathcal{A}$'s $\IND$ game using $\mathcal{B}$.}
		\end{table}
	\end{proof}
	
	
	\newpage
	\section{Classification of Ability of Adversary}
	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf }]
		\begin{enumerate}[(1)]
			\item Passive Attack ($\PASS$), a.k.a Ciphertext-Only Attack ($\mathsf{COA}$)
			\item Chosen-Plaintext Attack ($\CPA$)
			\item Chosen-Ciphertext Attack ($\CCA$)
			\item Adaptive Chosen-Ciphertext Attack ($\CCATwo$)
		\end{enumerate}
	\end{tcolorbox}
	
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf }]
		\begin{theorem}
			\[
			\text{$\CCATwo$-secure}\Rightarrow\text{$\CCA$-secure}\Rightarrow\text{$\CPA$-secure}\Rightarrow\text{$\PASS$-secure}.
			\]
		\end{theorem}
	\end{tcolorbox}
	
	\newpage
	\section{Security Relation}
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf }]
		\begin{theorem}
			$\IND$-secure scheme is $\OW$-secure.
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		Note that the following game: \begin{table}[h]
			\centering\begin{tabular}{ccccc}
				\toprule[1.5pt]
				Challenger & $\xleftrightarrow[\textnormal{game}]{\IND}$ & Adversary $\mathcal{A}$ & $\xleftrightarrow[\textnormal{game}]{\OW}$ & Adversary $\mathcal{B}$ \\
				\midrule
				$k\uniform\GenKey(1^n)$\\
				& $\xleftarrow{p_0,p_1}$ & $p_0,p_1\gets\A$\\
				$b\uniform\set{0,1}$\\
				\midrule
				$c\gets\Encrypt(k;p_b)$ & $\xrightarrow{c}$ & & $\xrightarrow{c}$\\
				\midrule
				if $b=b'$, then & \multirow{3}{*}{$\xleftarrow{b'}$} & if $p_0=\hat{p}$, then, &\multirow{3}{*}{$\xleftarrow{\hat{p}}$} & $\A$ thinks $\hat{p}$ \\
				$\mathcal{A}$ wins, & & $b'\gets 0$, & & s.t.\\
				else $\mathcal{A}$ loses. & & else $b'\gets 1$ & & $\Decrypt(k;c)=\hat{p}$\\
				\bottomrule[1.5pt]
			\end{tabular}
			\caption{$\mathcal{A}$'s $\IND$ game using $\mathcal{B}$.}
		\end{table}\\
	\end{proof}
	\vspace{8pt}
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf }]
		\begin{theorem}
			Deterministic scheme is \textbf{NOT} $\IND$-$\CPA$-secure.
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		content...
	\end{proof}
	\vspace{4pt}
	\begin{example}
		{Textbook RSA} is deterministic, and so it is not $\IND$-$\CPA$-secure.
	\end{example}
	\vspace{8pt}
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf }]
		\begin{theorem}
			Homomorphic scheme is \textbf{NOT} $\OW$-$\CCATwo$-secure.
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		content...
	\end{proof}
	
	\newpage
	\section{Authentication and Signature}
	
	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf Message Authentication Code (MAC)}]
		\begin{enumerate}[(1)]
			\item Key Generation: $\GenKey:\N\to\mathcal{K}$; $k\gets\GenKey(1^n)$ for a security parameter $n$
			\item Value gen: $\GenMacTag:\mathcal{K}\times\mathcal{M}\to\mathcal{T}$; $tag\gets\GenMacTag(k;m)$
			\item Gen. Verify: $\VerifyMacTag:\mathcal{K}\times\mathcal{M}\times\mathcal{T}\to\set{\vaild,\invaild}$; $ans\gets\VerifyMacTag(k;m,tag)$
		\end{enumerate}
	\end{tcolorbox}
	\vspace{8pt}
	\begin{tcolorbox}[colback=white,colframe=defcolor,arc=5pt,title={\color{white}\bf Signature}]
		\begin{enumerate}[(1)]
			\item Key Generation: $\GenKeyPair:\N\to\mathcal{K}_p\times\mathcal{K}_s$; \[
			pk,sk\gets\GenKeyPair(1^n)
			\] for a security parameter $n$
			\item Gen. sig.: $\Sign:\mathcal{K}_p\times\mathcal{M}\to\mathcal{S}$;
			$$sig\gets\Sign(pk;m)$$
			\item Gen. veri.: $\Verify:\mathcal{K}_s\times\mathcal{M}\times\mathcal{S}\to\set{\vaild,\invaild}$;
			$$ans\gets\Verify(sk;m,sig)$$
		\end{enumerate} We call $pk$ public key and $sk$ secret key (or private key).
	\end{tcolorbox}
	
	
	\newpage
	\chapter{IFP-based Ciphers}
	
	\section{$\RSA$-$\OAEP$}
	Since both $\mathsf{Textbook}$ $\RSA$ and $\RSA$-$\mathsf{CRT}$ are deterministic algorithms, they are not $\IND$-$\CPA$-secure. In 1994, M. Bellare and P. Rogaway proposed a method of transforming a deterministic algorithm into a specific protocol unrelated to the key before encrypting the message using a random oracle, to ensure $\IND$-$\CPA$-secure. This is referred to as $\OAEP$ (Optimal Asymmetric Encryption Padding) transformation.
	\begin{figure}[h!]
		\centering
		\begin{tikzpicture}[>=stealth',node distance=.3cm, 
		box/.style={rectangle,draw=black,minimum size=1cm}]
		
		\node[] (A) {Plaintext $p$};
		\node[box,above right=of A] (B) {$\OAEPEncode(*)$};
		\node[right=of A] (M) {\textcolor{red}{un-keyed function}};
		\node[right=of M] (C) {Encoded plaintext $\hat{p}$};
		\node[right=of C] (N) {\textcolor{blue}{keyed function}};
		\node[box,above right=of C] (D) {$\Encrypt(pk;*)$};
		\node[right=of N] (E) {Ciphertext $c$};
		\node[box,below=of N] (F) {$\Decrypt(sk;*)$};
		\node[box,below right=of A] (G) {$\OAEPDecode(*)$};
		
		%\node[above=of B, blue] (S) {};
		%\node[above=of D, red] (T) {};
		%\node[below=of G, blue] (U) {un-keyed function};
		%\node[below=of F, red] (V) {keyed function};
		
		\draw[->] (A) to[out=90,in=180] (B);
		\draw[->] (B) to[out=0,in=90] (C);
		\draw[->] (C) to[out=90,in=180] (D);
		\draw[->] (D) to[out=0,in=90] (E);
		\draw[->, dashed] (E) to[out=-90,in=0] (F);
		\draw[->, dashed] (F) to[out=180,in=-90] (C);
		\draw[->, dashed] (C) to[out=-90,in=0] (G);
		\draw[->, dashed] (G) to[out=180,in=-90] (A);
		
		
		%\draw[dashed, blue] (S) to[out=0,in=90] (C);
		%\draw[dashed, blue] (C) to[out=-90,in=0] (U);
		%\draw[dashed, blue] (U) to[out=180,in=-90] (A);
		%\draw[dashed, blue] (A) to[out=90,in=180] (S);
		
		%\draw[dashed, red] (T) to[out=0,in=90] (E);
		%\draw[dashed, red] (E) to[out=-90,in=0] (V);
		%\draw[dashed, red] (V) to[out=180,in=-90] (C);
		%\draw[dashed, red] (C) to[out=90,in=180] (T);
		\end{tikzpicture}
		\caption{OAEP Transformation}
	\end{figure}
	
	\begin{algorithm}[H]
		\caption{$\RSA$-$\OAEP$: $\Encrypt$, $\Decrypt$}
		\vspace{8pt}
		\begin{multicols}{2}
			\KwData{A public key $pk$, and a plaintext $p$}
			\KwResult{A ciphertext $c$ or \texttt{error}}
			\BlankLine
			\Comment{$pk=(e,N)$}
			\Procedure{$\Encrypt(pk; p)$}{
				$\hat{p}\gets\OAEPEncode(p)$\;
				\If{$\hat{p}=$\texttt{error}}{
					\Return \texttt{error}\;
				}
				$c\gets\of{\hat{p}}^e\mod N$\;
				\Return $c$\;
			}
			\columnbreak % Move to the next column
			\setcounter{AlgoLine}{0}  % Reset line numbering
			\KwData{A secret key $sk$, and a ciphertext $c$}
			\KwResult{A ciphertext $p$ or \texttt{error}}
			\BlankLine
			\Comment{$sk=(d,N)$}
			\Procedure{$\Decrypt(sk; c)$}{
				$\hat{p}\gets c^d\mod N$\;
				$p\gets\OAEPDecode(\hat{p})$\;
				\If{$p=$\texttt{error}}{
					\Return \texttt{error}\;
				}
				\Return $p$\;
			}
		\end{multicols}
		\vspace{8pt}
	\end{algorithm}
	
	\begin{figure}[h!]
		\begin{tikzpicture}[
		block/.style={rectangle, draw, text width=2.5cm, align=center},
		line/.style={draw, -latex}
		]
		\node[block] (db) {DB = lHash $\|$ PS $\|$ 01 $\|$ M};
		\node[block, below = 2cm of db] (seed) {Seed};
		\node[block, right = 2cm of db] (xor1) {XOR};
		\node[block, below = 2cm of xor1] (mgf1) {MGF};
		\node[block, left = 2cm of mgf1] (xor2) {XOR};
		\node[block, below = 2cm of xor2] (maskedseed) {00 $\|$ MaskedSeed};
		\node[block, right = 2cm of maskedseed] (maskeddb) {MaskedDB};
		\node[block, below = 2cm of maskeddb] (em) {EM = 00 $\|$ MaskedSeed $\|$ MaskedDB};
		
		\path[line] (db) -- (xor1);
		\path[line] (seed) -- (xor2);
		\path[line] (seed.east) -- (mgf1.north);
		\path[line] (mgf1) -- (xor1);
		\path[line] (xor2) -- (maskedseed);
		\path[line] (xor1) -- (maskeddb);
		\path[line] (maskedseed) -- (em);
		\path[line] (maskeddb) -- (em);
		\end{tikzpicture}
		\caption{$\RSA$-$\OAEP$ Encoding Operation}
	\end{figure}
	
	\begin{algorithm}[H]
		\caption{$\RSA$-$\OAEP$: $\OAEPEncode$
		}
		\KwData{An plaintext $p$, an optional label $L$ (default = \texttt{NULL})}
		\KwResult{An encoded plaintext $\hat{p}$ or \texttt{error}}
		\BlankLine
		\Procedure{$\OAEPEncode(p,L)$}{
			$k,m,h\gets$ \tcp*{$N=pq$}
			\If{$m>k-2h-2$}{
				\Return \texttt{error}\;
			}
			\BlankLine
			\Comment{$\underbrace{\texttt{DB}}_{k-h-1}=\underbrace{\texttt{lHash}}_h\parallel\underbrace{\texttt{PS}}_{k-2h-2-m}\parallel\underbrace{\texttt{0x01}}_1\parallel\underbrace{p}_{m}$}
			\BlankLine
			\Construct{\texttt{DB}}{
				\texttt{lHash}$\gets(L)\in\set{0,1}^{8h}$\;
				\texttt{PS}$\gets\texttt{0x00}^{(k-2h-2-m)}$\;
				\texttt{DB}$\gets(\texttt{lHash},\texttt{PS},\texttt{0x01},p)\in\set{0,1}^{8h}\times\set{0,1}^{8(k-2h-2-m)}\times\set{0,1}^8\times\set{0,1}^{8m}$
			}
			\BlankLine
			\texttt{seed}$\uniform\set{0,1}^{8h}$\;
			\texttt{maskedDB}$\gets$\;
		}
		\BlankLine
		\BlankLine
		\eIf{$\operatorname{\textnormal{Proj}}_2\of{X}\neq\operatorname{\textnormal{Proj}}_2\of{X'}$}{
			$t_1\gets\of{\operatorname{\textnormal{Proj}}_1(X)-\operatorname{\textnormal{Proj}}_1(X)}$\;
			$t_2\gets\of{\operatorname{\textnormal{Proj}}_2(X')-\operatorname{\textnormal{Proj}}_2(X')}^{-1}$\tcp*{EEA}
			\Return $t_1t_2\mod p$
		}{
			\Return \texttt{Failure}\;
		}
	\end{algorithm}
	\section{$\RSA$-$\mathsf{FDH}$}
	\section{$\RSA$-$\mathsf{PSS}$}
	
	\newpage
	\chapter{Primality Tests}
	
	\section{Distribution of Primes}
	
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf Prime Number Theorem}]
		\begin{theorem}
			The prime-counting function $\pi(n)$, that is, the number of primes less than $n$, satisfies: \[
			\lim\limits_{n\to\infty}\pi(n)\frac{\ln n}{n}=1\quad\of{\ie,\ \pi(n)\sim\frac{n}{\ln n}}.
			\]
		\end{theorem}
	\end{tcolorbox}
	\vspace{4pt}
	\begin{remark}
		\ \begin{table}[h]
			\centering
			\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}ccccccc}
				\toprule[1.2pt]
				$n$ & $512$ & $1024$ & $1536$ & $2048$ & $3840$ & $7680$ \\
				\midrule
				$\pi(2^n)-\pi(2^{n-1})$ & $2^{502.53}$ & $2^{1013.53}$ & $2^{1524.94}$ & $2^{2036.53}$ & $2^{3827.62}$ & $2^{7666.62}$ \\
				\bottomrule[1.2pt]
			\end{tabular*}
		\end{table}
	\end{remark}
	\vspace{4pt}
	\begin{lstlisting}[style=sage, caption={Prime-Counting Function (Sage)},captionpos=t]
	def pi (n) : return n / ln(n)
	N = [512, 1024, 1536, 2048, 3840, 7680]
	for n in N :
	U, L = 2^n, 2^(n-1)
	T = pi(U) - pi(L)
	print (n, log(T,2).n())
	
	'''
	512 502.525940328866
	1024 1013.52735542414
	1536 1524.94286369947
	2048 2036.52806141567
	3840 3827.62149992868
	7680 7666.62168788972
	'''
	\end{lstlisting}
	
	\newpage
	\section{Classification of Primality Tests}
	Primality tests is classified into the following two types:
	
	\begin{enumerate}
		\item \textbf{Deterministic Primality Tests} (return provable prime):
		
		These are algorithms that determine with certainty whether a number is prime or not. For every input, they will always return the same output. An example of a deterministic primality test is the AKS primality test, which operates in polynomial time.
		
		A deterministic primality test, like the AKS, proceeds by eliminating every possible way that the number could be composite (not prime). This means that if the number passes the test, it is definitely a prime number.
		
		Pros:
		
		They always provide the correct answer.
		They are useful when absolute certainty is needed.
		
		Cons:
		
		They are usually slower than probabilistic tests, especially for large numbers
		\vspace{4pt}
		\item \textbf{Probabilistic Primality Tests} (return probable prime):
		
		These are algorithms that determine whether a number is probably prime, with a certain level of confidence. For large numbers, these tests are often much faster than deterministic tests. Examples of probabilistic primality tests include the Miller-Rabin and the Solovay-Strassen tests.
		
		A probabilistic test, like Miller-Rabin, works by randomly selecting values and performing a series of computations. If the number fails any of these computations, it is definitely composite. But if it passes, it is only "probably" prime. However, by performing the test multiple times with different randomly selected values, the probability that a composite number will be mistakenly identified as prime (called a "false positive") can be made arbitrarily small.
		
		Pros:
		
		They are often much faster than deterministic tests, especially for large numbers.
		They can provide a "probably prime" answer that is good enough for most practical purposes.
		
		Cons:
		
		They may provide false positives, although the probability can be made very small.
	\end{enumerate}
	
	In short, the choice between deterministic and probabilistic primality tests often comes down to a trade-off between speed and certainty.
	
	\newpage
	\section{Deterministic Primality Test}
	\subsection{Naive Test}
	
	\begin{algorithm}[H]
		\caption{Naive Primality Test}
		\KwData{$n\in\Z_{>1}$}
		\KwResult{Composite or Prime}
		\BlankLine
		\If{$n=2$}{
			\Return Prime\;
		}
		\If{$2\mid n$}{
			\Return Compostie\;
		}
		\For{$j\gets 1$ \KwTo $\floor*{\frac{\sqrt{n}}{2}}$}{
			\If{$(2j+1)\mid n$}{
				\Return Composite\;
			}
		}
		\Return Prime\;
	\end{algorithm}
	
	\subsection{Wilson Theorem}
	
	
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf Wilson Theorem}]
		\begin{theorem}
			Let $n\in\Z_{>1}$. Then \[
			\iff (n-1)!\equiv -1\pmod{n}.
			\]
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		\begin{itemize}
			\item[($\Leftarrow$)]
			\item[($\Rightarrow$)]
		\end{itemize}
	\end{proof}
	
	\newpage
	\section{Probabilistic Primality Test}
	\subsection{Fermat Primality Test: Application of FLT}
	
	\begin{algorithm}[H]
		\caption{Fermat Primality Test}
		\KwData{odd $n$ and witness $k$}
		\KwResult{Composite or Probable Prime}
		\BlankLine
		\While{$k>0$}{
			$k\gets k-1$\;
			$a\uniform[2,n-2]$\;
			\If{$\gcd(a,n)\neq 1$}{
				\Return Composite\;
			}
			\If{$a^{n-1}\not\equiv 1\mod{n}$}{
				\Return Composite\;
			}
		}
		\Return Probable Prime\;
	\end{algorithm}
	\vspace{4pt}
	\begin{remark}
		$1^{n-1}\equiv1\pmod{n}$ and \begin{align*}
		(n-1)^{n-1}&=\underbrace{(n-1)(n-1)\cdots(n-1)}_{n-1\ \text{times}}\\
		&\equiv\underbrace{(-1)(-1)\cdots(-1)}_{n-1\ \text{times}}\pmod{n}\\
		&=(-1)^{n-1}\\
		&=-1\quad\because n-1\in 2\Z
		\end{align*}
	\end{remark}
	\vspace{4pt}
	\begin{remark}[Carmichael Number]
		\[
		\forall a\in\Z:a^n\equiv a\pmod{n}
		\]
	\end{remark}
	
	\subsection{Miller-Rabin Primality Test}
	
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		
	\end{tcolorbox}
	
	% End document
\end{document}
