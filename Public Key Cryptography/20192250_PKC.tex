\documentclass[12pt,openany]{book}

\usepackage{amsmath,amsthm,amsfonts,amscd} % Packages for mathematics

% Colors
\usepackage[dvipsnames]{xcolor}
\definecolor{titleblue}{RGB}{0,53,128}
\definecolor{chaptergray}{RGB}{140,140,140}
\definecolor{sectiongray}{RGB}{180,180,180}

\definecolor{thmcolor}{RGB}{231, 76, 60}
\definecolor{defcolor}{RGB}{52, 152, 219}
\definecolor{lemcolor}{RGB}{155, 89, 182}
\definecolor{corcolor}{RGB}{46, 204, 113}
\definecolor{procolor}{RGB}{241, 196, 15}

% Fonts
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{newpxtext,newpxmath}
\usepackage{sectsty}
\allsectionsfont{\sffamily\color{titleblue}\mdseries}

% Page layout
\usepackage{geometry}
\geometry{a4paper,left=1.5in,right=1in,top=1in,bottom=1in,heightrounded}
\usepackage{fancyhdr}
\fancyhf{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[LO]{\nouppercase{\rightmark}}
\fancyhead[RE]{\nouppercase{\leftmark}}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}

% Chapter formatting
\usepackage{titlesec}
\titleformat{\chapter}[display]
{\normalfont\sffamily\Huge\bfseries\color{titleblue}}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titleformat{\section}
{\normalfont\sffamily\Large\bfseries\color{titleblue!100!gray}}{\thesection}{1em}{}
\titleformat{\subsection}
{\normalfont\sffamily\large\bfseries\color{titleblue!50!gray}}{\thesubsection}{1em}{}

% Table of contents formatting
\usepackage{tocloft}
\renewcommand{\cftchapfont}{\sffamily\color{titleblue}\bfseries}
\renewcommand{\cftsecfont}{\sffamily\color{chaptergray}}
\renewcommand{\cftsubsecfont}{\sffamily\color{sectiongray}}
\renewcommand{\cftchapleader}{\cftdotfill{\cftdotsep}}

% Hyperlinks
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=titleblue,
	filecolor=black,      
	urlcolor=titleblue,
}

%Listing
\usepackage{listings} %Code
\renewcommand{\lstlistingname}{Code}%

\definecolor{sagegreen}{rgb}{0.0,0.6,0.4}
\definecolor{sagepurple}{rgb}{0.6,0.0,0.4}
\definecolor{sageblue}{rgb}{0.0,0.4,0.6}
\definecolor{sageorange}{rgb}{1.0,0.4,0.0}
\definecolor{sagegray}{rgb}{0.4,0.4,0.4}

\lstdefinestyle{sage}{
	language=Python,
	backgroundcolor=\color{white},
	basicstyle=\small\ttfamily\color{black}, 
	basicstyle=\footnotesize\ttfamily\color{black},
	keywordstyle=\color{blue!60!black},
	commentstyle=\color{green!60!black},
	stringstyle=\color{purple!60!black},
	showstringspaces=false,
	breaklines=true,
	tabsize=4,
	morekeywords={True, False, None},
	frame=leftline, % Remove the border
	framesep=3pt,
	frameround=tttt,
	framexleftmargin=3pt,
	numbers=left,
	numberstyle=\small\color{gray},
	xleftmargin=15pt, % Increase the left margin
	xrightmargin=5pt,
	captionpos=b,
	belowskip=0pt,
	aboveskip=4pt
}

%Ceiling and Floor Function
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

%Algorithm
\usepackage[ruled,linesnumbered]{algorithm2e}
\usepackage{setspace}
\usepackage{algpseudocode}
\SetKwComment{Comment}{/* }{ */}
\SetKw{Break}{break}


%---------------------------My Preamble
\usepackage{enumerate}
\usepackage{soul}
\newcommand{\mathcolorbox}[2]{\colorbox{#1}{$\displaystyle #2$}}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{calc}

%Tcolorbox
\usepackage[most]{tcolorbox}
\tcbset{colback=white, arc=5pt}
%\tcbset{enhanced, colback=white,colframe=black,fonttitle=\bfseries,arc=4mm,boxrule=1pt,shadow={2mm}{-1mm}{0mm}{black!50}}
%White box with black text and shadow
%\begin{tcolorbox}[colback=white,colframe=black,fonttitle=\bfseries,title=Black Shadow Box,arc=4mm,boxrule=1pt,shadow={2mm}{-1mm}{0mm}{black!50}]
%	This is a white box with black text and a subtle shadow. The shadow adds some depth and dimension to the box without overpowering the design.
%\end{tcolorbox}

%Theorem
\newtheorem{axiom}{Axiom}[chapter]
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\newtheorem{remark}{Remark}[chapter]
\newtheorem{exercise}{Exercise}[chapter]
\newtheorem{example}{Example}[chapter]
\newtheorem*{note}{Note}

%New Command
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\nbhd}{\mathcal{N}}

\newcommand{\inv}[1]{#1^{-1}}

\newcommand{\ie}{\textnormal{i.e.}}
\newcommand{\eg}{\textnormal{e.g.}}

\newcommand{\of}[1]{\left( #1 \right)} 
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\norm}[1]{\left\| #1 \right\|}

\newcommand{\sol}{\textcolor{magenta}{\bf Sol}}

\newcommand{\img}{\operatorname{\textnormal{Img}}}
\newcommand{\id}{\operatorname{\textnormal{Id}}}

\newcommand{\dollar}{\$}
\newcommand{\uniform}{\xleftarrow{\dollar}}
\newcommand{\hash}{\mathsf{H}}

% Begin document
\begin{document}
	
	% Title page
	\begin{titlepage}
		\begin{center}
			{\Huge\textsf{\textbf{Abstract Algebra}}\par}
			\vspace{0.5in}
			{\Large Ji Yong-Hyeon\par}
			\vspace{1in}
			%\includegraphics[width=3in]{algebra.png}\par
			\vspace{1in}
			{\large Ji Yong-Hyeon\par}
			{\large \today\par}
		\end{center}
	\end{titlepage}
	
	% Table of contents
	\tableofcontents
	
	% Chapters
	\mainmatter
	
	\chapter{Public Key Cryptography in a Nutshell: Classification and Security Notions}
	
	\section{PKE}
	Signature, Key Establishment
	
	Onewayness Trapdoor, IND-CCA2, EUF-CMA
	
	
	\newpage
	\chapter{IFP-based Primitives}
	
	\section{Textbook RSA}
	
	RSA is a public-key cryptosystem that uses the mathematics of prime numbers to secure communication over the internet. It is widely used in various applications, such as digital signatures, secure email, and online banking.
	
	The RSA cryptosystem is based on the following mathematical concepts:
	
	
	\begin{itemize}
		\item Modular arithmetic:
		- a mod b (remainder when a is divided by b)
		- Euler's totient function phi(n) (number of positive integers less than n that are coprime to n)
		\item Prime factorization:
		- finding the unique prime factors of a given integer
		\item The Chinese Remainder Theorem:
		- a theorem that provides a solution to a system of linear congruences with pairwise relatively prime moduli
		\item Fermat's Little Theorem:
		- a theorem that states that if p is a prime number and a is an integer not divisible by p, then $a^{(p-1)}$ is congruent to 1 modulo p.
		\item Euler's Theorem:
		- a generalization of Fermat's Little Theorem that states that if a and n are coprime, then $a^{(\phi(n))}$ is congruent to 1 modulo n.
	\end{itemize}
	
	\subsection{The RSA Algorithm}
	
	\subsubsection{Key Generation}
	To generate an RSA key pair, we follow these steps:
	\begin{enumerate}
		\item Choose two large prime numbers $p$ and $q$.
		\item Compute $n = pq$ and $\phi(n) = (p-1)(q-1)$.
		\item Choose an integer $e$ such that $1 < e < \phi(n)$ and $\gcd(e, \phi(n)) = 1$.
		\item Compute $d$ such that $de \equiv 1 \pmod{\phi(n)}$.
	\end{enumerate}
	The public key is $(n, e)$, and the private key is $d$.
	
	\subsubsection{Encryption}
	To encrypt a message $M$, we use the public key $(n, e)$ and compute:
	$$C = M^e \pmod{n}$$
	The ciphertext $C$ is then sent to the recipient.
	
	\subsubsection{Decryption}
	To decrypt the ciphertext $C$, we use the private key $d$ and compute:
	$$M = C^d \pmod{n}$$
	The plaintext $M$ is then recovered.
	
	\subsection{Security}
	RSA is secure because it is based on the difficulty of factoring large integers. If an attacker can factor $n$ into its prime factors $p$ and $q$, then they can compute $\phi(n)$ and derive the private key. However, factoring large numbers is currently considered computationally infeasible, making RSA a secure choice for many applications.
	
	\subsection{Conclusion}
	RSA is a widely used public-key cryptosystem that uses prime numbers to secure communication over the internet. It is based on the difficulty of factoring large integers and is currently considered secure for many applications.
	
	
	\section{RSA-CRT}
	
	RSA-CRT is a modified version of the RSA public-key cryptosystem that leverages the Chinese Remainder Theorem to enhance the speed of the decryption process.
	
	RSA-CRT works by first generating two large primes, $p$ and $q$, and computing the modulus $n=pq$. Then, the public and private keys are generated using the usual RSA key generation algorithm.
	
	When encrypting a message, the sender uses the recipient's public key to encrypt the message, as in standard RSA. However, when decrypting a message, the recipient first computes two intermediate values, $m_1$ and $m_2$, using the Chinese Remainder Theorem. These values are then combined to obtain the original message.
	
	The Chinese Remainder Theorem states that given a system of linear congruences with pairwise relatively prime moduli, there exists a unique solution modulo the product of the moduli. In the case of RSA-CRT, the two moduli are $p$ and $q$, which are both primes, and the system of congruences is:
	
	$$\begin{aligned} m \equiv c^d \pmod{p}\ m \equiv c^d \pmod{q}\end{aligned}$$
	
	where $c$ is the encrypted message, $d$ is the recipient's private key, and $m$ is the decrypted message.
	
	The two intermediate values, $m_1$ and $m_2$, are computed as:
	
	$$\begin{aligned} m_1 &\equiv c^d \pmod{p}\ m_2 &\equiv c^d \pmod{q}\end{aligned}$$
	
	These values can be computed efficiently using modular exponentiation, which is much faster than using the standard RSA decryption algorithm to compute $m$ directly.
	
	Finally, the original message can be recovered by combining $m_1$ and $m_2$ using the Chinese Remainder Theorem:
	
	$$m \equiv m_1 + q((m_2 - m_1)q^{-1} \bmod p) \pmod n$$
	
	where $q^{-1}$ is the modular inverse of $q$ modulo $p$. This formula allows the recipient to efficiently compute the original message without having to compute the expensive modular exponentiation step for the entire modulus $n$.
	
	\begin{tcolorbox}[colback=white!10!white,colframe=blue!50!black,title=RSA-CRT Algorithm]
		\begin{enumerate}
			\item Generate two large primes $p$ and $q$, and compute $n = pq$.
			\item Generate the public and private keys using the usual RSA key generation algorithm. That is, \begin{enumerate}
				\item Compute the totient of n, $\phi(n) = (p - 1)(q - 1)$.
				\item Choose an integer $e$ such that \[
				1 < e < \phi(n)\quad \text{and}\quad \gcd(e, \phi(n)) = 1.
				\] This is the public key exponent.
				\item Compute the private key exponent $d$ such that \[
				d\equiv\inv{e} \pmod{\phi(n)}.
				\] This can be done efficiently using the Extended Euclidean Algorithm.
			\end{enumerate}
			The public key is $(n, e)$, and the private key is $(n, d)$.
			\item To encrypt a message $\mathcal{M}$, use the recipient's public key to compute \[
			\mathcal{C} = \mathcal{M}^e \mod{n}.
			\]
			\item To decrypt a message $\mathcal{C}$, compute the two intermediate values: \begin{enumerate}
				\item $m_1 = \mathcal{C}^d \mod p$.
				\item $m_2 = \mathcal{C}^d \mod q$.
			\end{enumerate}
			\item Combine the two intermediate values using the Chinese Remainder Theorem to obtain the original message $\mathcal{M}$: \[
			\mathcal{M} = m_1+q\of{\of{m_2-m_1}\inv{q}\mod p}\pmod{n}.
			\]
		\end{enumerate}
	\end{tcolorbox}
	
	\begin{tcolorbox}[title=Chinese Remainder Theorem]
		\begin{theorem}
			Given a system of linear congruences with pairwise relatively prime moduli:
			\begin{align*}
				x&\equiv a_1 \pmod{m_1}\\
				x&\equiv a_2 \pmod{m_2}\\
				&\vdots \\
				x&\equiv a_n \pmod{m_1},
			\end{align*}
			
			there exists a unique solution $x$ modulo $M = m_1m_2\cdots m_n$:
			\begin{align*}
				x&\equiv a_1b_1M_1+a_2b_2M_2+\cdots a_nb_nM_n\pmod{M}, \ie,\\ x&\equiv\sum_{i=1}^{n}a_ib_iM_i\pmod{M}
			\end{align*}\[
			\] where $M_i=M/m_i$ and $b_i$ is the inverse of $M_i$ modulo $m_i$.
		\end{theorem}
	\end{tcolorbox}
	
	\section{Fermat's Little Theorem}
	
	\begin{tcolorbox}[title=Fermat's Little Theorem]
		\begin{theorem}
			Let $p$ is a prime number and $a$ is an integer not divisible by $p$, then \[
			a^{p-1}\equiv1 \pmod{p}.
			\] In other words, if we take any non-zero integer $a$ and raise it to the power $p-1$, then divide the result by a prime $p$, the remainder will always be 1. This theorem is widely used in number theory and cryptography.
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		We use mathematical induction and binomial theorem. \begin{enumerate}
			\item (Basic Step) Let $a=1$, then $1^{p-1}=1\equiv\pmod{p}$, which is true.
			\item (Inductive Step) Suppose that the theorem holds for some integer $a$. We need to show that it also holds for $a+1$. We can express $(a+1)^{p}$ as: \[
			\of{a+1}^p=\sum_{i=0}^{p}\binom{p}{i}a^{i} 1^{p-i}
			\]
		\end{enumerate}
	\end{proof}
	Using the binomial theorem. Since $p$ is a prime number, we know that $\binom{p}{i}$ is divisible by $p$ for $0<i<p$, hence:
	
	$$(a+1)^{p} \equiv a^{p} + 1^{p} \equiv a + 1 \pmod{p}$$
	
	The last step follows from the fact that $a^{p-1} \equiv 1 \pmod{p}$. Therefore, we have shown that:
	
	$$(a+1)^{p-1} \equiv 1 \pmod{p}$$
	
	which completes the proof of Fermat's Little Theorem.
	
	\begin{proof}
		We use the group theory of the multiplicative group of integers modulo a prime $p$.
		
		Let $p$ be a prime number, and let $a$ be an integer that is not divisible by $p$. Consider the set of integers modulo $p$, denoted by $\mathbb{Z}/p\mathbb{Z}$. This set forms a group under multiplication, denoted by $(\mathbb{Z}/p\mathbb{Z})^{\times}$. Since $p$ is prime, the group $(\mathbb{Z}/p\mathbb{Z})^{\times}$ has order $p-1$, which means that it contains $p-1$ distinct elements.
		
		Now consider the subset of $(\mathbb{Z}/p\mathbb{Z})^{\times}$ consisting of the multiples of $a$, denoted by $S_a = {a, 2a, 3a, \ldots, (p-1)a}$. Since $a$ is not divisible by $p$, the set $S_a$ consists of distinct elements. We claim that $S_a$ is a permutation of the elements of $(\mathbb{Z}/p\mathbb{Z})^{\times}$.
		
		To prove this claim, we need to show that every element of $(\mathbb{Z}/p\mathbb{Z})^{\times}$ can be expressed as a multiple of $a$ modulo $p$. Suppose for the sake of contradiction that there exists an element $b \in (\mathbb{Z}/p\mathbb{Z})^{\times}$ that cannot be expressed as $b = ka \pmod{p}$ for any integer $k$. Then the integers $1a, 2a, \ldots, (p-1)a$ would not be distinct modulo $p$, which contradicts our assumption that $S_a$ consists of distinct elements. Therefore, $S_a$ is a permutation of the elements of $(\mathbb{Z}/p\mathbb{Z})^{\times}$.
		
		Since $S_a$ is a permutation of the elements of $(\mathbb{Z}/p\mathbb{Z})^{\times}$, we can multiply all the elements of $S_a$ together to obtain:
		
		$$a \cdot 2a \cdot \ldots \cdot (p-1)a \equiv 1 \cdot 2 \cdot \ldots \cdot (p-1) \pmod{p}$$
		
		which simplifies to:
		
		$$(p-1)!a^{p-1} \equiv (p-1)! \pmod{p}$$
		
		Since $p$ does not divide $(p-1)!$, we can cancel out $(p-1)!$ from both sides to obtain:
		
		$$a^{p-1} \equiv 1 \pmod{p}$$
		
		This completes the proof of Fermat's Little Theorem using the theory of abstract algebra.
	\end{proof}
	
	\newpage
	\section{Euler's Theorem}
	
	Euler's Theorem is a generalization of Fermat's Little Theorem. It states that if $a$ and $n$ are two positive integers that are coprime, then:
	
	$$a^{\varphi(n)} \equiv 1 \pmod{n}$$
	
	where $\varphi(n)$ is Euler's totient function, which gives the number of positive integers less than or equal to $n$ that are coprime with $n$. Euler's Theorem is useful in cryptography for testing the primality of large numbers and for computing modular exponentiations efficiently.
	
	Proof: We can prove Euler's Theorem using the fact that the totient function is multiplicative, which means that if $m$ and $n$ are two coprime positive integers, then:
	
	$$\varphi(mn) = \varphi(m) \varphi(n)$$
	
	We can use this property to reduce the theorem to the case where $n$ is a prime power $p^k$, where $p$ is a prime and $k$ is a positive integer. If $k=1$, then Euler's Theorem reduces to Fermat's Little Theorem. Otherwise, we can use the Chinese Remainder Theorem to combine the solutions of $a^{\varphi(p^k)} \equiv 1 \pmod{p^k}$ for all prime powers $p^k$ that divide $n$. Since the exponents $\varphi(p^k)$ are powers of $p$, we can use repeated squaring to compute the modular exponentiations efficiently. This completes the proof of Euler's Theorem.
	
	\begin{proof}
		Euler's Theorem is a generalization of Fermat's Little Theorem and states that if $a$ and $n$ are two coprime positive integers, then
		
		$$a^{\varphi(n)} \equiv 1 \pmod{n}$$
		
		where $\varphi(n)$ is Euler's totient function, which gives the number of positive integers less than or equal to $n$ that are coprime with $n$.
		
		To prove Euler's Theorem, we first define a group $G$ of integers modulo $n$ that are coprime with $n$. This group is denoted as:
		
		$$G = {a \in \mathbb{Z}_n | gcd(a,n)=1}$$
		
		Next, we define the function $f(a) = ra \pmod{n}$ where $r$ is a fixed integer coprime with $n$. It can be shown that $f$ is a permutation of $G$ and that the order of the group $G$ is $\varphi(n)$.
		
		Now, we consider the product of all elements in $G$:
		
		$$P = \prod_{a \in G} f(a) = \prod_{a \in G} ra \pmod{n}$$
		
		We can rewrite this product as:
		
		$$P = r^{\varphi(n)} \prod_{a \in G} a \pmod{n}$$
		
		Since $a$ is coprime with $n$, we know that $a$ has a unique inverse $b$ in the group $G$ such that $ab \equiv 1 \pmod{n}$. Therefore, we can rewrite the product as:
		
		$$P = r^{\varphi(n)} \prod_{a \in G} a \prod_{a \in G} b = r^{\varphi(n)} \prod_{a \in G} 1 = r^{\varphi(n)}$$
		
		where we used the fact that $ab \equiv 1 \pmod{n}$ and that $a$ and $b$ are both in the group $G$.
		
		On the other hand, we can rearrange the terms in the product as:
		
		$$P = \prod_{a \in G} f(a) = \prod_{a \in G} (ar) \pmod{n} = r^{\varphi(n)} \prod_{a \in G} a \pmod{n}$$
		
		where we used the fact that $ar$ is also in the group $G$ since $r$ is coprime with $n$.
		
		Equating the two expressions for $P$, we get:
		
		$$r^{\varphi(n)} \prod_{a \in G} a \equiv r^{\varphi(n)} \prod_{a \in G} a \pmod{n}$$
		
		Dividing both sides by $\prod_{a \in G} a$, we obtain:
		
		$$r^{\varphi(n)} \equiv 1 \pmod{n}$$
		
		which is Euler's Theorem.
	\end{proof}
	
	\section{Primality Test}
	
	A primality test is a method used to determine if a given positive integer is a prime number or a composite number. There are various primality tests, and they differ in their speed, accuracy, and the range of numbers they can handle.
	
	One of the simplest and most well-known primality tests is the trial division method. This method involves dividing the number by each integer from 2 up to the square root of the number, checking if any of the divisors evenly divide the number. If no divisor is found, then the number is prime. However, this method becomes impractical for very large numbers, as the number of potential divisors to check grows with the number being tested.
	
	Another primality test is the Fermat primality test. This test is based on Fermat's Little Theorem, which states that if $p$ is a prime number and $a$ is any integer not divisible by $p$, then $a^{p-1} \equiv 1 \pmod p$. The Fermat primality test uses this theorem to check if a number is prime by randomly selecting values of $a$ and checking if the equation holds for each value. If the equation fails for any $a$, then the number is composite. If the equation holds for many values of $a$, the number is likely prime, but there is still a small chance it could be composite.
	
	The Miller-Rabin primality test is a more sophisticated primality test that is based on the same idea as the Fermat test but is more efficient and has a higher probability of correctly identifying composite numbers. The Miller-Rabin test involves selecting a random value $a$ and then repeatedly squaring it and checking if the resulting values satisfy the equation $a^{d} \equiv 1 \pmod n$ or $a^{2^rd} \equiv -1 \pmod n$ for some values of $r$ and $d$. If the equation holds for many values of $r$ and $d$, the number is likely prime, but if the equation fails for any $r$ or $d$, the number is composite.
	
	There are also deterministic primality tests that can determine with certainty whether a number is prime or composite. One example is the AKS primality test, which is based on a polynomial-time algorithm and can handle very large numbers. However, deterministic tests are generally more complex and slower than probabilistic tests.
	
	\section{EEA}
	\section{CRT}
	
	\newpage
	IFP-based Schemes
	
	RSA-OAEP, RSA-PSS
	
	Random Oracle Model
	
	
	How to Implement IFP-based Schemes Part 1
	
	Integer Multiplication, Division, (Modular) Exponentiation
	
	
	How to Implement IFP-based Schemes Part 2
	
	Barrett Reduction, Montgomery Reduction
	
	
	How to Solve IFP Part 1
	
	Birthday Bound, Floyd's Cycle Detection
	
	Pollard’s p-1 method, Pollard’s rho method
	
	
	How to Solve IFP Part 2
	
	Quadratic Residue mod p (Legendre symbol), Square Roots modulo p
	
	QS, GNFS
	
	
	Midterm Exam. (04.20.)
	
	
	DLP-based Schemes
	
	DH, DSA, KCDSA
	
	
	How to Solve DLP Part 1
	
	Baby-Step/Giant-Step Algorithm, Pollard’s rho method
	
	
	How to Solve DLP Part 2
	
	Pohlig-Hellman Algorithm, Index Calculus Method
	
	
	Elliptic Curve Cryptography Part 1
	
	Projective Space, Elliptic Curve, Elliptic Curve Group
	
	ECDH, ECDSA, EC-KCDSA
	
	
	Elliptic Curve Cryptography Part 2
	
	Addition, Doubling
	
	NIST Curves, Curve25519
	
	
	Post-Quantum Cryptography
	
	NIST PQC, KpqC
	
	
	\newpage
	\chapter{Integer Factorization Problem}
	
	\section*{Pollard's $p-1$ Method}
	Pollard's $p-1$ method is an algorithm for factoring a composite number $N$ when one of its prime factors, $p$, has a small prime factor in $p-1$. The method is based on Fermat's Little Theorem and relies on the properties of the greatest common divisor (GCD) function.
	
	\subsection*{Mathematical Background}
	Fermat's Little Theorem states that if $p$ is a prime number and $a$ is an integer not divisible by $p$, then
	\[
	a^{p-1} \equiv 1 \pmod{p}.
	\]
	Now, let $N = pq$ be a composite number with two prime factors $p$ and $q$. Let $a$ be a random integer such that $1 < a < N$. If we can find an integer $k$ such that
	\[
	a^k \equiv 1 \pmod{p},
	\]
	then we have
	\[
	a^k - 1 \equiv 0 \pmod{p},
	\]
	which implies that $p \mid (a^k - 1)$. Since $p$ and $q$ are distinct primes, it is unlikely that $q \mid (a^k - 1)$, so we expect that
	\[
	\text{gcd}(a^k - 1, N) = p,
	\]
	and we can find the other prime factor as $q = \frac{N}{p}$.
	
	Pollard's $p-1$ method aims to find such an integer $k$. The idea is to choose a bound $B$ and compute the least common multiple of all primes less than or equal to $B$, denoted by $\text{lcm}(1, 2, \ldots, B)$. If $p-1$ has only small prime factors less than or equal to $B$, then
	\[
	k = \text{lcm}(1, 2, \ldots, B)
	\]
	will satisfy the desired property.
	
	The algorithm proceeds as follows:
	
	\begin{enumerate}
		\item Choose a bound $B$ and a random integer $a$ such that $1 < a < N$.
		\item Compute $k = \text{lcm}(1, 2, \ldots, B)$.
		\item Compute $g = \text{gcd}(a^k - 1, N)$.
		\item If $g$ is a nontrivial factor of $N$ (i.e., $1 < g < N$), return $g$ as the prime factor of $N$. Otherwise, choose a new bound $B$ and repeat from step 1.
	\end{enumerate}
	
	The success of Pollard's $p-1$ method depends on the choice of the bound $B$ and the prime factors of $p-1$. If the algorithm fails to find a nontrivial factor, a larger bound or other factoring methods can be employed.
	
	Let $p$ be a prime number. We want to show that there exists an integer $n_0 \in \mathbb{Z}$ such that for all $n \geq n_0$, $p-1 \mid n!$. 
	
	Consider the integer $n_0 = p - 1$. Now, let $n \geq n_0$. We know that $n! = 1 \cdot 2 \cdot 3 \cdots (p-1) \cdots n$. Since $p$ is a prime number and $n_0 = p - 1$, it follows that $p-1$ is the largest integer smaller than $p$. Therefore, there must be at least one factor of $(p-1)$ in the product $1 \cdot 2 \cdot 3 \cdots (p-1) \cdots n$. 
	
	Now, we know that $p-1$ divides itself, so $p-1 \mid (p-1)$. Since the product $n!$ contains a factor of $(p-1)$, we can conclude that $p-1 \mid n!$ for all $n \geq n_0$. This completes the proof.
	
	\newpage
	Let $p$ be a prime number. Now, consider the set $S = {n \in \mathbb{Z} \mid n \geq p, p-1 \nmid n!}$. This is the set of integers greater than or equal to $p$ for which $p-1$ does not divide $n!$. Our goal is to show that this set is empty.
	
	Assume for the sake of contradiction that $S$ is non-empty. Then by the well-ordering principle, there exists a least element $n_0 \in S$. By the definition of the set $S$, we have that $p-1 \nmid n_0!$.
	
	Since $n_0 \geq p$, we can write $n_0 = pk + r$, where $k \in \mathbb{Z}_{\geq 0}$ and $0 \leq r < p$. Note that $r \neq p-1$ because otherwise, we would have $n_0 = pk + (p-1)$, which implies $p-1 \mid n_0!$, a contradiction.
	
	Now consider $(n_0 - r)!$. Since $0 \leq r < p$, we have $n_0 - r \geq pk$. Therefore, $(n_0 - r)! = (pk)! = p^k k!$, and clearly, $p-1 \mid (n_0 - r)!$ because $p^k$ is divisible by $p-1$ for every positive integer $k$.
	
	Using the properties of factorials, we can write $n_0! = (n_0 - r)!(n_0 - r + 1)(n_0 - r + 2) \cdots n_0$. Since $p-1 \mid (n_0 - r)!$, it suffices to show that $p-1 \mid (n_0 - r + 1)(n_0 - r + 2) \cdots n_0$.
	
	Notice that $n_0 - r + 1, n_0 - r + 2, \dots, n_0$ are consecutive integers, and among them, there must be a multiple of $p-1$ because the range contains at least $p-1$ integers. Let $n_0 - r + i$ be a multiple of $p-1$, where $1 \leq i \leq p-1$.
	
	Since $p-1 \mid (n_0 - r + i)$ and $p-1 \mid (n_0 - r)!$, we have that $p-1 \mid n_0!$, which contradicts our assumption that $n_0 \in S$. Therefore, our assumption that $S$ is non-empty must be false.
	
	Thus, the set $S$ is empty, which means that for all $n \geq n_0$, $p-1 \mid n!$.
	
	\newpage
	
	\begin{proof}
		Let $p$ be a prime number. We want to prove that there exists a natural number $n_0$ such that for all $n \geq n_0$, $p-1$ divides $n!$. 
		
		Consider the set $S = \{k \in \mathbb{N} \mid k! \equiv 0 \pmod{p-1}\}$, which is the set of all natural numbers $k$ such that $p-1$ divides $k!$. We will show that this set is non-empty and then use the well-ordering principle to find its minimum element.
		
		First, note that for $k = p-1$, we have $(p-1)! \equiv 0 \pmod{p-1}$, since $(p-1)$ is a factor of $(p-1)!$. Therefore, $p-1 \in S$, and the set $S$ is non-empty.
		
		By the well-ordering principle, $S$ has a least element, say $n_0$. So, we have $n_0! \equiv 0 \pmod{p-1}$. We want to show that for all $n \geq n_0$, $p-1$ divides $n!$.
		
		Let $n \geq n_0$. Then we can write $n$ as $n = n_0 + k$ for some non-negative integer $k$. Now, consider $(n_0 + k)!$. By the definition of the factorial, we have:
		
		\begin{align*}
			(n_0 + k)! &= (n_0 + k)(n_0 + k - 1) \cdots (n_0 + 1)n_0!
		\end{align*}
		
		Since $n_0! \equiv 0 \pmod{p-1}$ and $p-1$ divides each of the factors $(n_0 + k), (n_0 + k - 1), \ldots, (n_0 + 1)$ exactly once, we have $(n_0 + k)! \equiv 0 \pmod{p-1}$. Therefore, $p-1$ divides $(n_0 + k)!$, which is equivalent to $n!$.
		
		Thus, for all $n \geq n_0$, $p-1$ divides $n!$. This completes the proof.
	\end{proof}
	
	\begin{proof}
		Let $N = pq$, where $p$ and $q$ are prime numbers, and let $a$ be an integer such that $\gcd(a, p) = 1$. We want to prove that
		\begin{equation} \label{eq:congruence}
			(a^{(j+1)!} - 1) \mod N = (a^{j!} \mod N)^{j+1} \mod N - 1.
		\end{equation}
		
		To prove this, we can use the following properties of modular arithmetic:
		\begin{align}
			(ab) \mod N &\equiv (a \mod N)(b \mod N) \mod N, \label{eq:mod_product} \\
			(a^b) \mod N &\equiv ((a \mod N)^b) \mod N. \label{eq:mod_power}
		\end{align}
		
		We start by calculating $(a^{j!} \mod N)^{j+1} \mod N$. By applying property \eqref{eq:mod_power}, we have
		\begin{equation} \label{eq:step1}
			(a^{j!} \mod N)^{j+1} \mod N \equiv a^{j!(j+1)} \mod N.
		\end{equation}
		
		Next, we calculate $(a^{(j+1)!} - 1) \mod N$. Since $(j+1)! = (j+1)j!$, we have
		\begin{equation} \label{eq:step2}
			(a^{(j+1)!} - 1) \mod N \equiv (a^{(j+1)j!} - 1) \mod N.
		\end{equation}
		
		Now we need to show that the right-hand sides of \eqref{eq:step1} and \eqref{eq:step2} are congruent modulo $N$. To do this, we use the property \eqref{eq:mod_product}:
		\begin{align*}
			(a^{(j+1)j!} - 1) \mod N &\equiv (a^{j!(j+1)} - 1) \mod N \\
			&\equiv ((a^{j!})^{j+1} - 1) \mod N \\
			&\equiv (a^{j!(j+1)} \mod N - 1) \mod N,
		\end{align*}
		where the last step follows from property \eqref{eq:mod_product}.
		
		Thus, we have shown that $(a^{(j+1)!} - 1) \mod N \equiv (a^{j!} \mod N)^{j+1} \mod N - 1$, which completes the proof.
	\end{proof}
	
	\newpage
	\begin{proof}[Proof of $(ab) \mod N \equiv (a \mod N)(b \mod N) \mod N$]
		Let $a$ and $b$ be integers, and let $N$ be a positive integer. We want to show that $(ab) \mod N \equiv (a \mod N)(b \mod N) \mod N$.
		
		By the definition of modulo, we have
		\begin{align*}
			a &\equiv a_1 \pmod{N}, \\
			b &\equiv b_1 \pmod{N},
		\end{align*}
		for some integers $a_1$ and $b_1$ such that $a \equiv a_1 \pmod{N}$ and $b \equiv b_1 \pmod{N}$.
		
		Then, $a = a_1 + k_1N$ and $b = b_1 + k_2N$ for some integers $k_1$ and $k_2$. Therefore,
		\begin{align*}
			ab &= (a_1 + k_1N)(b_1 + k_2N) \\
			&= a_1b_1 + a_1k_2N + b_1k_1N + k_1k_2N^2 \\
			&= a_1b_1 + (a_1k_2 + b_1k_1 + k_1k_2N)N.
		\end{align*}
		
		Since $a_1k_2 + b_1k_1 + k_1k_2N$ is an integer, we have $ab \equiv a_1b_1 \pmod{N}$. But $a_1 \equiv a \pmod{N}$ and $b_1 \equiv b \pmod{N}$, so we can rewrite the congruence as
		\begin{align*}
			(ab) \mod N &\equiv (a \mod N)(b \mod N) \mod N.
		\end{align*}
		This completes the proof.
	\end{proof}
	
	\begin{proof}[Proof of $(a^b) \mod N \equiv ((a \mod N)^b) \mod N$]
		Let $a$ be an integer, let $b$ be a non-negative integer, and let $N$ be a positive integer. We want to show that $(a^b) \mod N \equiv ((a \mod N)^b) \mod N$.
		
		By the definition of modulo, we have
		\begin{align*}
			a &\equiv a_1 \pmod{N},
		\end{align*}
		for some integer $a_1$ such that $a \equiv a_1 \pmod{N}$.
		
		Then, $a = a_1 + kN$ for some integer $k$. Therefore,
	\end{proof}
	
	\begin{proof}
		We want to prove that for any integers $a$, $b$, and $N$ with $N > 0$, the following property holds:
		\begin{equation} \label{eq:mod_power}
			(a^b) \mod N \equiv ((a \mod N)^b) \mod N.
		\end{equation}
		
		By the definition of congruence, there exists an integer $k$ such that $a = kN + r$, where $r = a \mod N$. Then, we have
		\begin{equation} \label{eq:mod_rep}
			a \equiv r \pmod{N}.
		\end{equation}
		
		Now, we raise both sides of \eqref{eq:mod_rep} to the power $b$ and obtain
		\begin{equation} \label{eq:mod_power_step1}
			a^b \equiv r^b \pmod{N}.
		\end{equation}
		
		Taking both sides of \eqref{eq:mod_power_step1} modulo $N$, we have
		\begin{equation} \label{eq:mod_power_step2}
			(a^b) \mod N \equiv (r^b) \mod N.
		\end{equation}
		
		Since $r = a \mod N$, we can rewrite \eqref{eq:mod_power_step2} as
		\begin{equation} \label{eq:mod_power_step3}
			(a^b) \mod N \equiv ((a \mod N)^b) \mod N.
		\end{equation}
		
		Thus, we have shown that the property $(a^b) \mod N \equiv ((a \mod N)^b) \mod N$ holds, which completes the proof.
	\end{proof}
	
	
	\chapter{Pollard $\rho$ Method}
	\section{Birthday Attack}
		
	The birthday problem (also known as the birthday paradox) is a famous problem in probability theory that demonstrates the surprising fact that, in a group of just 23 people, there is a greater than 50\% chance that at least two of them share the same birthday. It is based on the assumption that birthdays are uniformly distributed throughout the year (ignoring leap years).
	
	\subsection{Birthday Bound}
	Let $n$ be the number of people in the group. Consider \[
	a_1,\cdots,a_k\uniform\set{1,\cdots, n}\quad\text{with $k\leq n$}.
	\] Let $P(n)$ be the probability that at least two people share a birthday: \[
	P\of{n}:=\Pr\left[\exists (i,j):i\neq j\Rightarrow a_i=a_j\right].
	\] To calculate this probability, let $P'\of{n}:=1-P\of{n}$ then \begin{align*}
		P'\of{n}&=1-\Pr\left[\exists (i,j):i\neq j\Rightarrow a_i=a_j\right]\\
		&=\Pr\left[\lnot\of{\exists (i,j):i\neq j\Rightarrow a_i=a_j}\right]\\
		&=\Pr\left[\forall(i,j):i\neq j\land a_i\neq a_j\right].
	\end{align*}
	That is, $P' (n)$ be the probability that all $n$ birthdays are unique.
	
	Assuming there are 365 possible birthdays, the probability that the first person has a unique birthday is:
	\begin{equation*}
		P'_1 = \frac{365}{365} = 1.
	\end{equation*}
	
	For the second person to have a unique birthday (different from the first person), there are 364 remaining possibilities:
	\begin{equation*}
		P'_2 = \frac{364}{365}.
	\end{equation*}
	
	For the third person to have a unique birthday (different from the previous two), there are 363 remaining possibilities:
	\begin{equation*}
		P'_3 = \frac{363}{365}.
	\end{equation*}
	
	Following this pattern, the probability that all $n$ birthdays are unique is:
	\begin{equation*}
		P'(n) = \frac{365}{365} \times \frac{364}{365} \times \cdots \times \frac{365 - (n - 1)}{365}.
	\end{equation*}
	
	Thus, the probability that at least two people share a birthday is:
	
	\begin{equation*}
		P(n) = 1 - P'(n)=1-\of{\frac{365}{365}}\of{\frac{364}{365}}\cdots\of{\frac{365-(n-1)}{365}}.
	\end{equation*}

	\begin{tcolorbox}[colback=white,colframe=procolor,arc=5pt,title={\color{white}\bf Generalization of Birthday Problem}]
		\begin{proposition}
			Assume all birthday are equally likely, and generalize the problem a little: \textnormal{from $n$ possible birthdays, sample $k$ times with replacement}. \begin{align*}
				P(\textnormal{a shared birthday})&=1-P(\textnormal{no shared birthdays})\\
				&=1-P(\textnormal{all birthdays are unique})\\
				&=1-\of{\frac{n}{n}}\of{\frac{n-1}{n}}\cdots\of{\frac{n-(k-1)}{n}}\\
				&=1-1\cdot \prod_{i=1}^{k-1}\frac{n-i}{n}\\
				&=1-\prod_{i=1}^{k-1}\of{1-\frac{i}{n}}.
			\end{align*}
		\end{proposition}
	\end{tcolorbox}

	\newpage
	\begin{remark}
		When $n=365$, the lowest $k$ for which the above exceeds $0.5$ is $k=23$: \begin{figure}[ht!]
			\centering
			\includegraphics[width=0.95\linewidth,height=95mm]{birthday_problem.png}
		\end{figure}
		\begin{lstlisting}[style=sage, caption={Birthday Bound (Sage)},captionpos=t]
import matplotlib.pyplot as plt

# Define a function to compute the probability of two people sharing a birthday for a given group size
def birthday_prob(n):
	return 1 - prod([(365-i)/365 for i in range(n)])

# Create a list of group sizes from 2 to 50
group_sizes = range(2, 51)

# Compute the probabilities for each group size
probabilities = [birthday_prob(n) for n in group_sizes]

# Plot the probabilities as a function of group size
plt.plot(group_sizes, probabilities)
plt.xlabel("Group Size")
plt.ylabel("Probability")
plt.title("Probability of Two People Sharing a Birthday")

# Add a horizontal line at the probability of 0.5
plt.axhline(y=0.5, color='r', linestyle='-')

plt.show()
		\end{lstlisting}
	\end{remark}

	\newpage
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf Birthday Bound}]
		\begin{theorem}
			From the set $I:=\set{1,\cdots,n}$, sample $k$ times with replacement: \[
			a_1,a_2,\cdots,a_k\uniform\set{1,2,\cdots,n}
			\] where all element of $I$ are equally likely. Then \[
			P_{n,k}:=\Pr\left[\exists \of{i,j}\in I^2, i\neq j:a_i=a_j\right]\approx 1-e^{-\frac{k^2}{2n}}.
			\]
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		Note that \begin{align*}
			P_{n,k}=1-\Pr[(i,j)\in I^2, i\neq j\implies a_i\neq a_j]=1-\prod_{i=1}^{k-1}\of{1-\frac{i}{n}}.
		\end{align*} Recall that Taylor series for exponential: \[
		e^x=1+x+\frac{1}{2!}x^2+\frac{1}{3!}x^3+\cdots=\sum_{k=0}^{\infty}\frac{x^k}{k!}.
		\] Note that $e^x\approx1+x$ for $x\in(-1,1)$:
		\begin{figure}[ht!]
			\centering
			\includegraphics[scale=0.5]{approx_exp.png}
		\end{figure}\\
		Since $i\in[1,k-1]\subseteq[1,n)\Rightarrow-\frac{i}{n}\in\of{-1,1}\Rightarrow 1+\of{-\frac{i}{n}}\approx e^{-i/n}$, we have \begin{align*}
			P_{n,k}=
			1-\prod_{i=1}^{k-1}\of{1-\frac{i}{n}}
			&\approx 1-\prod_{i=1}^{k-1}e^{-\frac{i}{n}}\\
			&=1-e^{-1/n}\cdot e^{-2/n}\cdots e^{-(k-1)/n}\\
			&=1-e^{-\frac{1}{n}\of{1+2+\cdots+(k-1)}}\\
			&=1-e^{-\frac{1}{n}\cdot\frac{k\of{k-1}}{2}}\\
			&\approx 1-e^{-\frac{k^2}{2n}}.
		\end{align*}
	\end{proof}

	\begin{remark}
		Find minimum value of $k$ such that $P_{n,k}\geq 1/2$. \begin{align*}
		P_{n,k}=1-e^{-\frac{k^2}{2n}}\geq\frac{1}{2}&\implies e^{-k^2/2n}\leq\frac{1}{2}\\
		&\implies-\frac{k^2}{2n}\leq\ln\frac{1}{2}\\
		&\implies (2\ln2)n\leq k^2\\
		&\implies \ceil*{\sqrt{\of{2\ln 2}n}}\leq k.
		\end{align*} 
		Thus, $k\geq c\sqrt{n}$, where $c$ is a constant. That is, $O(\sqrt{n})$.
	\end{remark}

	\begin{remark}
		Find the upper bound of $P_{n,k}$. \begin{align*}
			P_{n,k}
			&=\Pr\left[(a_1=a_2)\lor\cdots\lor(a_1=a_k)\lor(a_2=a_3)\lor\cdots\lor(a_{k-1}=a_k)\right]\\
			&\leq\sum_{1\leq i< j\leq k}\Pr\left[a_i=a_j\right]\\
			&=\binom{k}{2}\frac{1}{n}\\
			&\leq\frac{k^2}{2n}.
		\end{align*} Thus, the upper bound of $P_{n,k}$ is less than 1/2 when $k=\floor*{\sqrt{n}}$.
	\end{remark}
	
	\subsection{Set Intersection Bound}
	
	\newpage
	\section{Finding Collision of a (One-way) Function}
	
	Finding a collision for a one-way function is a computationally hard problem. We can define a one-way function as:
	\[
	f : \set{0,1}^*\to \set{0,1}^n
	\] By the pigeon-hole principle, there are \hl{collision}. A collision in a one-way function is a pair of inputs:
	\[
	x_1,x_2\in\set{0,1}^*\ \text{such that}\ f\of{x_1}=f\of{x_2}\ \text{but}\ x_1\neq x_2.
	\]
	
	One common method used to find a collision is the \textit{birthday attack}, which is based on the birthday paradox. The birthday paradox states that in a group of 23 people, there is a 50\% chance that two people share the same birthday, assuming uniform distribution of birthdays over 365 days.
	
	\begin{algorithm}[H]
		\caption{{Birthday Attack} to Find a Collision in a One-way Function}
		\KwData{One-way function $f$.}
		\KwResult{Collision pair $(x_1,x_2)$.}
		\vspace{4pt}
		\vspace{4pt}
		\begin{minipage}{.45\textwidth}
			Initialize an empty set $S=\varnothing$\;
			\vspace{4pt}
			\While{\texttt{True}}{
				$x\uniform\set{0,1}^*$\;
				$y\gets f\of{x}$\;
				\eIf{$y\in S$}{
					\Return $(x_1,x_2)$ s.t. $f\of{x_1}=f\of{x_2}=y$\;
				}{
					$S\gets S\cup\set{y}$\;
				}
			}
		\vspace{15pt}
		\end{minipage}\hfil
		\begin{minipage}{.45\textwidth}
			Initialize an empty dictionary $D$\;
			\vspace{4pt}
			\While{\texttt{True}}{
				$x\uniform\set{0,1}^*$\;
				$y\gets f\of{x}$\;
				\eIf{$y$ is a key in $D$}{
					$x_1\gets x$\;
					$x_2\gets D[y]$\;
					\Return $(x_1,x_2)$\;
				}{
					$D\gets D\cup\set{(y,x)}$\;
				}
			}
		\end{minipage}
		\vspace{4pt}
	\end{algorithm}
	The dictionary stores $D$ key-value pairs where the key is the output value $y$ and the value is the corresponding input value 
	$x$. This way, we can keep track of the input values corresponding to the computed output values.
	
	\newpage
	\subsection{Native Approach}
	
	From $2^n$ possible outputs of $f$, sample $k$ times with replacement: \[
	P\of{\textnormal{no collision for $k$ inputs}}=\prod_{i=1}^{k-1}\of{1-\frac{i}{2^n}}.
	\]
	Then \begin{align*}
		\prod_{i=1}^{k-1}\of{1-\frac{i}{2^n}}\approx e^{-\frac{k^2}{2\cdot 2^n}}\geq\frac{1}{2}
		&\implies (2\ln2)2^n\leq k^2\\
		&\implies \sqrt{2\ln2}\sqrt{2^n}\leq k.
	\end{align*}
	For $N=O(\sqrt{2^n})$, we generate the set of input/output pairs \[
	S=\set{\of{x_i,f\of{x_i}}}_{i=1}^N.
	\] By the birthday bound, \[
	\Pr[\exists(x_i,f(x_i)),(x_j,f(x_j))\in S:f(x_i)=f(x_j)]\approx\frac{1}{2}.
	\]
	\vspace{8pt}
	\begin{remark}[Memory Space]
		To store $k$ inputs, each of which is represented by $n$ bits, we need $k \times n$ bits. If we consider that the probability of a collision is greater than 50\% when $k > \sqrt{2^n}$, the memory space required to store these inputs is approximately: \[
		\sqrt{2^n}\times n.
		\] Thus the memory space needed to store $n$-bit i/o is approximately $\sqrt{2^n}\times n\times 2$.
	\end{remark}
	\vspace{8pt}
	\begin{example}
		Consider $160$-bit output function. Then 
		\begin{align*}
			\text{Memory space} &= \sqrt{2^n} \times n \times 2 \\
			&= 2^{80} \times 160 \times 2 \\
			&= 2^{80} \times 2^5\times 5 \times 2 \\
			&= 10\times 2^{85}\\
			&= 10\times 2^{82} \times 2^3 (= 10\times 2^{82}\ \text{bytes})\\
			&= 10 \times 2^{42}\ \text{TB}.
		\end{align*}
	\end{example}
	
	\newpage
	\subsection{Small-Space Attack using Floyd's Cycle-Finding}
	Consider a function $f:X\to X$ satisfying: \begin{enumerate}
		\item $\abs{X}<\infty$
		\item $f\neq id$\footnote{$id$: identity mapping.}, \ie, $\exists x\in D_f=X$ such that $f(x)\neq x$.
	\end{enumerate} Using above function $f$, we define a sequence $\set{x_i}_{i=1}$ as follows: \[
	x_{i+1}:=f(x_i).
	\] We can visualize this sequence as follows: \begin{center}
		\begin{tikzcd}
			x_0 \arrow[r, "f"] & x_1 \arrow[r, "f"] & x_2 \arrow[r, "f"]        & \cdots \arrow[r, "f"] & x_n \arrow[r, "f"]                                                  & x_{n+1} \arrow[r, "f"] & \cdots \\
			x_0 \arrow[r]      & f(x_0) \arrow[r]   & (f\circ f)(x_0) \arrow[r] & \cdots \arrow[r]      & \underbrace{(f\circ\cdots\circ f)}_{n\ \text{times}}(x_0) \arrow[r] & f(x_n) \arrow[r]       & \cdots
		\end{tikzcd}
	\end{center} Here, $x_0\in\set{x\mid f(x)\neq x}$. Note that a sequence $\set{x_i}$ has a collision pair because $\abs{X}<\infty$ (feat. pigeon-hole principle).
	
	\newpage
	\begin{tcolorbox}[colback=white,colframe=thmcolor,arc=5pt,title={\color{white}\bf }]
		\begin{theorem}
			Define a sequence $\set{x_i}$ as follows: \[
			x_{i+1}:=f\of{x_i}
			\] Then $\exists k>i$ such that $x_k=x_{2k}$:
			\begin{center}
			\begin{tikzcd}
				\cdots \arrow[r, "f"] & x_i \arrow[r, "f"] & x_{i+1} \arrow[r, "f"] & \cdots \arrow[r, "f"] & x_k(=x_{2k}) \arrow[d, "f"] \\
				&                    & x_j \arrow[u, "f"]     &                       & \cdots \arrow[ll, "f"]     
			\end{tikzcd}
			\end{center}
		\end{theorem}
	\end{tcolorbox}
	\begin{proof}
		Let $(x_i, x_j)$ be a collision pair with $0\leq i< j\leq N\of{=O\of{\sqrt{2^n}}}$; that is, $\exists x_i,x_j$ such that $x_i\neq x_j$ but $f(x_i)=f(x_j)$, so 
		\begin{center}
		\begin{tikzcd}
			\cdots \arrow[r, "f"] & x_i \arrow[r, "f"] & x_{i+1} \arrow[r, "f"] & \cdots \arrow[d, "f"] \\
			&                    & x_j \arrow[u, "f"]     & \cdots \arrow[l, "f"]
		\end{tikzcd}
		\end{center}
		For $j>i$, we have a circular sequence \[
		\set{x_j}_{j>i}:\quad x_j,x_{i+1},x_{i+2},\cdots, x_{i+(j-i)}(=x_j),\cdots
		\] with the period $p=j-i>0$. That is, \[
		x_j = x_{j+t\cdot p}\quad\text{with}\quad t\in\Z_{\geq 0}.
		\]
		Define a number \[
		k:=\min\set{tp\in\mathbb{Z}_{>i}:t\in\mathbb{N}}>i.
		\] In other words, $k$ is the smallest multiple greater than $i$ of the period $p$. Since
		$p\mid k \implies p\mid 2k$, the equality $x_k=x_{2k}$ holds.
	\end{proof}
	\vspace{8pt}
	\begin{remark}
		We know that $\exists k>i$ such that $x_k=x_{2k}$. Since \begin{align*}
			x_k=f(x_{k-1}),\quad x_{2k}=f(x_{2k-1}),
		\end{align*} by the definition of $\set{x_j}$, then, we obtain $f(x_{k-1})=f(x_{2k-1})$. But $(x_{k-1},x_{2k-1})$ may not be a collision pair. \textcolor{blue}{Let $x_\alpha$ is the \underline{initial term} of a circular sequence $\set{x_j}$.} Since $k$ is a multiple of the period $p$ of $\set{x_j}$, we see that \begin{align*}
			x_\alpha&=x_{\alpha+k},\\
			f(x_{\alpha-1})&=f(x_{\alpha+k-1})\quad\text{by the def. of $\set{x_j}$},\\
		\end{align*} and so $(x_{\alpha-1},x_{\alpha+k-1})$ is a clear collision pair.
	\end{remark}

	\newpage
	%\SetKwComment{Comment}{/* }{ */}
	\begin{algorithm}[H]
		\caption{Finding Collision: Small-Space Attack}
		\KwData{One-way function $\hash:\set{0,1}^*\to\set{0,1}^n$.}
		\KwResult{Collision pair $(x,x')$ such that $x\neq x'$ but $\hash\of{x}=\hash\of{x'}$.}
		\vspace{4pt}
		\vspace{4pt}
		\Comment{Step1: We discover $k$ such that $x_k=x_{2k}$}
		\vspace{4pt}
		$x_0\uniform\set{0,1}^{n+1}$ \tcp*{$x_0\notin\img\hash$ is the start node}
		\vspace{4pt}
		$\of{x,x'}\gets\of{x_0,x_0}$\;
		\vspace{4pt}
		$k\gets 0$\;
		\vspace{4pt}
		\While{\texttt{True}}{
			$k\gets k+1$\;
			$\of{x,x'}\gets\of{H\of{x},\of{H\circ H}\of{x}}$\;
			\If{$x=x'$}{
				\Break\;
			}
		}
	\vspace{4pt}
		\Comment{Step2: Using $(x_0, x_k)$ obtained in Step1, we find the collision pair}
		\vspace{4pt}
		$\of{x,x'}\gets\of{x_0,x'}$\;
		\vspace{4pt}
		\For{$i\leftarrow 1$ \KwTo $k$}{
			\eIf{$\hash\of{x}=\hash\of{x'}$}{
				\Return $\of{x,x'}$
			}{
				$\of{x,x'}\gets\of{\hash\of{x},\hash\of{x'}}$\;
			}
		}
	\end{algorithm}

\newpage
	\begin{lstlisting}[style=sage, caption={Small-Sapce Attack (Sage)},captionpos=t]
N = 2^13 - 1 #12-bit
n = floor(sqrt(N))
print("N = {}\nn = floor(sqrt N) = {}\n".format(N,n))

def f(x):
	return (x^2 + 1) % N

# Step 1: Discover k such that x_k = x_{2k}
x0 = ZZ.random_element(N, 2*N) #x0 is the start node
x1, x2 = x0, x0
k = 0
while True :
	k = k + 1
	x1, x2 = f(x1), f(f(x2))
	if x1 == x2 :
		print ("k = {}, 2k = {}".format(k, 2*k))
		break

# Step 2: Find the collision pair
x1 , x2 = x0, x2
for i in [0..k]:
	if f(x1) == f(x2):
		print("Collision: ({}-th elt = {}, {}-th elt = {}) ".format(i, x1, k+i, x2))
		break
	else :
		x1, x2 = f(x1), f(x2)

L = [(0, x0)]
for j in [1..2*k]:
L = L + [(j, f(L[j-1][1]))]

# list_plot(L)

for pair in L:
print(pair)
	\end{lstlisting}

	\newpage
	\section{Fermat Factorization}
	\begin{tcolorbox}[colback=white,colframe=lemcolor,arc=5pt,title={\color{white}\bf }]
		\begin{lemma}
			Let $n\in 2\Z+1$. Define two sets: \begin{align*}
				S_n&:=\set{(a,b)\in\Z^2:n=ab\ \text{with}\ 0<b\leq a},\\
				T_n&:=\set{\of{u^2,v^2}\in\Z^2:n=u^2+v^2}.
			\end{align*} Then $\exists\phi:S_n\leftrightarrow T_n$. In other words, there exists a one-to-one correspondence between factorizations of $n$ into two positive integers and differences of two squares that equal $n$.
		\end{lemma}
	\end{tcolorbox}
	\begin{proof}
		Define two functions: \begin{align*}
			f:S_n\to T_n&:f\of{\of{a,b}}=\of{\of{\frac{a+b}{2}}^2,\of{\frac{a-b}{2}}^2},\\
			g:T_n\to S_n&:g\of{\of{u^2,v^2}}=\of{\abs{u}+\abs{v},\abs{u}-\abs{v}}.
		\end{align*} We claim that $g\circ f=\id_{S_n}$ and $f\circ g=\id_{T_n}$:\begin{align*}
		\of{g\circ f}(a,b)&=g\of{\of{\frac{a+b}{2}}^2,\of{\frac{a-b}{2}}^2}=\of{\abs{\frac{a+b}{2}}+\abs{\frac{a-b}{2}},\abs{\frac{a+b}{2}}-\abs{\frac{a-b}{2}}}\\
		&=\of{{\frac{a+b}{2}}+{\frac{a-b}{2}},{\frac{a+b}{2}}-{\frac{a-b}{2}}}\\
		&=\of{a,b},\\
		\of{f\circ g}\of{u^2,v^2}&=f\of{\abs{u}+\abs{v},\abs{u}-\abs{v}}=\of{\abs{u}^2,\abs{v}^2}=\of{u^2,v^2}.
	\end{align*}
	\end{proof}

To solve $3x\equiv 1\pmod{28}$, we need to find a value of $x$ such that $3x$ leaves a remainder of $1$ when divided by $28$. In other words, we need to find an integer $x$ such that $3x = 1 + 28k$ for some integer $k$.

We can start by multiplying both sides of the congruence by the inverse of $3$ modulo $28$. Since $3$ and $28$ are relatively prime, $3$ has an inverse modulo $28$. We can find it using the Euclidean algorithm:

\begin{align*}
	28 &= 3\times 9 + 1 \\
	1 &= 28 - 3\times 9
\end{align*}

Therefore, $1$ is the inverse of $3$ modulo $28$. Multiplying both sides of the congruence by $1$ gives:

\begin{align*}
	3x &\equiv 1\pmod{28} \\
	\Rightarrow \quad 1\times 3x &\equiv 1\times 1\pmod{28} \\
	\Rightarrow \quad x &\equiv 3^{-1}\pmod{28} \\
	\Rightarrow \quad x &\equiv 9\pmod{28}
\end{align*}

Therefore, the solution to the congruence $3x\equiv 1\pmod{28}$ is $x\equiv 9\pmod{28}$. We can check this solution by verifying that $3\times 9\equiv 1\pmod{28}$.

	% End document
\end{document}
